<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[你真的了解js对象的属性吗]]></title>
    <url>%2F2020%2F01%2F14%2F%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3js%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%97%2F</url>
    <content type="text"><![CDATA[JavaScript对象的属性，看起来是一个很简单的问题，但是往细了想有很多细节需要注意。比如，可枚举属性与不可枚举属性的区别是什么，当我们打印一个对象的时候，打印的是对象本身的属性，还是包含继承的属性？我们去遍历一个对象的时候，多种方法之间又有什么区别？在这里我们做一个全面的分析和总结。 属性的设置在搞清楚对象的属性之前，先看看我们一般如何设置一个对象的属性。总的来说有两种方法： 直接访问对象属性进行设置，这是最常用的 123456789// 1.直接设置属性，无论通过点还是中括号访问，效果都是一样的var obj = &#123;&#125;;obj.a = 1;obj['b'] = 2;// 2. 在构造函数中设置，本质上也是通过a访问。function Person (a) &#123; this.age = a;&#125;var a = new Person(11) 通过Object.defineProperty()方法。Object.defineProperty提供更强大的功能，他通过属性描述符来对属性进行更大的配置。属性描述符又分为数据描述符和存取描述符两类： 123456789101112131415161718192021222324var obj = &#123;&#125;;Object.defineProperty(obj, a, &#123; /***数据描述符***/ // 当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。 configurable: true, // 当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。 enumerable: false, // 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined value: 1, // 当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false writable: true, /***存取描述符***/ // 一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。当访问该属性时，该方法会被执行 get: function() &#123; console.log('获取属性a的值') return 1; &#125;, // 一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。 set: function(val) &#123; console.log('设置属性a的值') a = val;// 这里直接写属性名就行 &#125;&#125;) 属性的分类我们从3个维度来对JavaScript属性进行分类，这是后面进行分析的基础。 可枚举与不可枚举js对象的属性分为可枚举属性和不可枚举属性。通过上面说的第一种方法设置的属性都是可枚举属性，在第二种方法中，如果将数据描述符enumerable设置为false，则属性时不可枚举。对于大多数情况，我们使用的都是可枚举属性。 如果你去搜索可枚举和不可枚举属性的区别是什么，很多博客都是说会影响for...in等方法的行为。其实说白了，这些都是可枚举属性和不可枚举属性在表现上的区别，是果，不是因。关于具体的区别，我们将在下面介绍API时具体分析，在这里我们只用记住，可枚举与不可枚举是怎么来的就行。 继承与自身js对象是一大特点就是可继承性，所以我们常常提到原型链。如果属性设置在对象本身，我们就说这是自身属性，如果来自于原型链，我们就说这是继承属性。 12345678910111213function Parent() &#123; this.p1 = 'p1';&#125;var parent = new Parent();function Son () &#123; this.s1 = 's1';&#125;Son.prototype = parent;var son = new Son();console.log(son.p1) // 继承属性console.log(son.s1) // 自身属性 Symbol属性与非Symbol属性ES6引入了Symbol，于是又给属性分类多添了一种。 12345var skey = Symbol.for('symbolKey');function Son() &#123; this.s1 = 's1';// s1是非Symbol属性 this[skey] = 's3';// skey是Symbol属性&#125; Symbol属性与非Symbol属性只是key值的不同而已。设置Symbol属性往往是为了更加安全，不轻易暴露出来。所以在访问上，一般来说Symbol属性隐藏更深。 8种分类与4种分类从3个维度分类，每个维度有2种分类，所以排列组合一下，我们一共将js属性分为8类： 自身可枚举Symbol属性 自身可枚举非Symbol属性 自身不可枚举Symbol属性 自身不可枚举非Symbol属性 继承可枚举Symbol属性 继承可枚举非Symbol属性 继承不可枚举Symbol属性 继承不可枚举非Symbol属性 很复杂，有点多是不是。其实，Symbol属性只是key值的类型为Symbol而已，在一般情况下时作为私有属性，隐藏的更深，Symbol属性一般不会访问到。所以，为了简单起见，我们不单独考虑这种，默认都是访问不到的，只有在能访问到的时候才单独说明。所以，我们还是按照4种分类： 自身可枚举属性 自身不可枚举属性 继承可枚举属性 继承不可枚举属性 我们构造一个例子，包含上面这8种属性。下面的所有分析都在这个例子的基础上： 1234567891011121314151617181920212223242526272829303132333435363738var skeyEnumerable = Symbol.for('skeyEnumerable');var skeyNoEnumerable = Symbol.for('skeyNoEnumerable');var pkeyEnumerable = Symbol.for('pkeyEnumerable');var pkeyNoEnumerable = Symbol.for('pkeyNoEnumerable');function Parent() &#123; this.p1 = 'p1'; this[pkeyEnumerable] = 'pSymbolEnumerable';&#125;var parent = new Parent();Object.defineProperty(parent, 'p2', &#123; enumerable: false, value: 'p2'&#125;);Object.defineProperty(parent, pkeyNoEnumerable, &#123; enumerable: false, value: 'pSymbolNoEnumerable'&#125;);function Son() &#123; this.s1 = 's1'; this[skeyEnumerable] = 'sSymbolEnumerable';&#125;Son.prototype = parent;var son = new Son();Object.defineProperty(son, 's2', &#123; enumerable: false, value: 's2'&#125;);Object.defineProperty(son, skeyNoEnumerable, &#123; enumerable: false, value: 'sSymbolNoEnumerable'&#125;); 在这个例子中： s1是自身可枚举属性 s2是自身不可枚举属性 p1是继承可枚举属性 p2是继承不可枚举属性 除此之外，还有4个Symbol属性： skeyEnumerable是自身可枚举Symbol属性 skeyNoEnumerable是自身不可枚举Symbol属性 pkeyEnumerable是继承可枚举Symbol属性 pSymbolNoEnumerable是继承不可枚举Symbole属性 为了简单起见，我们只考虑上面4种。下面的4中Symbol属性，只有在会展示的地方，才会特殊说明。 如何区分分类根据上面说的两种分类，是解释来源，这里介绍如何鉴定区分。 区分是否可枚举通过实例方法propertyIsEnumerable来区分是否可枚举： 1234console.log(son.propertyIsEnumerable('s1'));// trueconsole.log(son.propertyIsEnumerable('s2'));// falseconsole.log(son.propertyIsEnumerable('p1'));// falseconsole.log(son.propertyIsEnumerable('p2'));// false 根据上面例子中的设置，p1是继承的可枚举属性，但是这里输出false。有点小遗憾，这个propertyIsEnumerable方法只是对自身的属性才有用，对继承的属性统一输出为false，无论是可枚举还是不可枚举。 区分是否继承通过实例方法hasOwnProperty来区分是否为继承属性。 1234console.log(son.hasOwnProperty('s1'));// trueconsole.log(son.hasOwnProperty('s2'));// trueconsole.log(son.hasOwnProperty('p1'));// falseconsole.log(son.hasOwnProperty('p2'));// false 打印对象直接打印如果我们直接将son对象打印出来，我们会得到什么？这4中属性里面，有哪些属性会被打印访问到呢？ 123console.log(son);// 在Chrome中，打印的结果是Son &#123;s1: "s1", s2: "s2"&#125;// 在node中，打印的结果是Parent &#123; s1: 's1' &#125; 可以看出打印出来的结果并不一致。这是因为，我们常用的console.log函数，并不是一个标准的方法，每个浏览器或引擎都有自己的一套实现方法，也并不是简单地调用对象的toString方法（如果是toString应该返回[object Object]），比如在Chrome中会打印可枚举和不可枚举，而在node中只会打印可枚举。需要提到的是，son.p1和son.p2是可以访问，只是这里没有打印出来。 至于Symbol属性，由于个平台实现不一致，有的能打印出来，有的不能，不多纠结。 JSON.stringify方法虽然console.log跨引擎实现是不一样的，但也不是很重要，毕竟这只是一个debug用的方法。换一种更通用的方法，通过JSON.stringfy序列化成字符换，最后的结果又是怎样呢 1console.log(JSON.stringify(son)); // &#123;"s1":"s1"&#125; 可以看出，JSON.stringify会将所有的自身可枚举属性序列化成字符串。 遍历对象属性前面介绍这么多，都是基础。在实际应用中，我们最多的还是去遍历一个对象。接下来就把所有遍历对象属性的方法做一个分析比较。 遍历对象的所有属性，就要先得到该对象的所有属性名。只有先得到所有的属性名，才能遍历每个属性的值。JS提供了很多API供我们得到所有的属性名，往往是放在一个数组中，然后遍历数组中的每一个key，访问对象对应的key值。 1. Object.keys()123Object.keys(son).forEach(key =&gt; &#123; console.log(son[key]);// s1&#125;); 该方法返回的是对象的所有自身可枚举属性。这跟JSON.stringify其实是一样的。 2. Object.getOwnPropertyNames()123Object.getOwnPropertyNames(son).forEach(key =&gt; &#123; console.log(son[key]);// s1 s2&#125;); 该方法返回的是对象自身的所有属性，包含可枚举属性和不可枚举属性。 3. Object.getOwnPropertySymbols()前面提到，一般Symbol属性都是私有的，隐藏的。而通过该方法可以访问到对象自身的所有Symbol属性，包括自身可枚举的Symbol属性和自身不可枚举Symbol属性。 123Object.getOwnPropertySymbols(son).forEach(key =&gt; &#123; console.log(son[key]); //sSymbolEnumerable sSymbolNoEnumerable&#125;) 4. Reflect.ownKeys()123Reflect.ownKeys(son).forEach(key =&gt; &#123; console.log(son[key]); // sSymbolEnumerable sSymbolNoEnumerable s1 s2&#125;) 这个方法就更强了，返回的是对象自身的所有属性，无论是否可枚举，也无论是否为Symbol属性，即包含： 自身可枚举Symbol属性 自身可枚举非Symbol属性 自身不可枚举Symbol属性 自身不可枚举非Symbol属性 到目前为止，介绍的几种方法都是访问对象自身的属性。Object.keys()是最弱的，只能访问自身可枚举属性，而Object.getOwnPropertyNames()就强一些，能访问自身可枚举和不可枚举属性；当然这些都不包含Symbol属性，需要使用Object.getOwnPropertySymbols来访问。可以说，Obejct.getOwnPropertySymbols和Object.getOwnPropertyNames是并列关系，而Reflec.ownKeys=Object.getOwnPropertyNames + Object.getOwnPropertySymbols。如下图所示： 5. for…in123for (var key in son) &#123; console.log(son[key]);// s1 p1&#125; 该方法访问的是对象的自身和继承的可枚举属性。 如果想用for…in来访问对象自身的可枚举属性，应该怎么弄呢。结合前面说的hasOwnProperty方法，做一个区分即可： 12345for (var key in son) &#123; if (son.hasOwnProperty(key)) &#123; console.log(son[key]); // s1 &#125;&#125; 小结为了方便区分记忆，我是按照从弱到强的方法来介绍各种方法的。除了Object.getOwnPropertySymbols和Reflect.ownKeys，其他方法都是访问不到Symbol属性的，这也是对于Symbole属性不多加区分的原因。大多数情况下的遍历，都是相对于对象自身的属性而言的。所以可以看到，这里提供的方法大多也都是针对对象自身属性的。如果像遍历继承属性，for...in的能力其实很弱。最简单的方法就是用前面的4种方法直接访问Son.prototype或者Object.getPrototypeOf(son)即可，比如： 123Reflect.ownKeys(Object.getPrototypeOf(son)).forEach(key =&gt; &#123; console.log(son[key]); // p1 p2 pSymbolEnumerable pSymbolNoEnumerable&#125;) 复制对象时的属性ES6提供的…和Object.assign方法，又是如何复制属性的呢。 扩展运算符1console.log(Reflect.ownKeys(&#123;...son&#125;));// [ 's1', Symbol(skeyEnumerable) ] 复制的对象自身的可枚举属性，包含Symbol属性和非Symbol属性 Object.assign1console.log(Reflect.ownKeys(Object.assign(&#123;&#125;, son)));// [ 's1', Symbol(skeyEnumerable) ] 复制的对象自身的可枚举属性，包含Symbol属性和非Symbol属性 小结按照优先级，最高的应是自身可枚举属性，其次是自身不可枚举属性，再往后是Symbol属性。对于继承属性最不重要，因为继承属性就是prototype自身的属性而已。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习webpack之三：使用loaders]]></title>
    <url>%2F2019%2F10%2F15%2F%E5%AD%A6%E4%B9%A0webpack%E4%B9%8B%E4%B8%89%EF%BC%9Aloaders%E4%B8%8Emodules%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[从前两篇博客来看，介绍的webpack主要作用都是：从入口js开始，将所有依赖的js打包成单个文件，并且将这个文件挂载到html模版上，最后在浏览器中显示生成的HTML。也就是目前涉及的都是html和js，这里介绍对其他静态资源的处理。 loaders到目前为止，我们引入的都是js文件，直接用ES6的import语句即可。单从导入的角度（不考虑打包等处理）来说，这是ES6本身就支持的。而webpack的一个强大功能，就是它将CSS、图片等一切都视为模块，这使得我们同样可以使用import或类似方式来导入CSS等静态资源。由于静态资源的种类很多，所以webpack本身并没有包含所有的功能，因为这会导致webpack非常臃肿。相反，webpack生态中提供多个loader，每种类型的静态文件，都可以通过配置特定的loader来导入。下面从CSS来看具体操作。 CSS的导入 首先，需要安装导入CSS需要的两个loader：css-loader和style-loader css-loader使我们可以用import的方式导入css文件 style-loader的作用是在html模板中创建style标签，并将打包生成的css代码插入到style中 安装命令如下： 1npm i css-loader style-loader -D 安装完成后，在webpack.config.js(或者是webpack.base.config.js/webpack.dev.config.js/webpack.prod.config.js)中配置使用： 12345678module.exports = &#123; module: &#123; rules: [&#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125;] &#125;&#125; rules是一个数组，其中每个元素都指定一套规则。所谓规则，就是指定什么类型的文件用哪一种loader。 test解决指定什么类型文件的问题，其值是一个正则表达式，对应import语句引入的文件后缀类型。如import &#39;./test.css&#39;，表示引入的是css后缀的文件，就适用这套规则，而import test from &#39;./test.vue&#39;就不适用。 use解决用哪一种loader的问题，其值是一个数组。当有多个loader时，webpack会依次从右向左执行。比如这里就是先执行css-loader打包，然后执行style-loader插入 配置完成后，在js中就可以使用了。比如在入口文件page1.js中引入一个css文件： 1234567import &#123;a&#125; from '../module/a';import &#123;b&#125; from '../module/b';import '../assets/css/base.css';var dom = document.createElement('div');dom.innerHTML = `index1 dd file, a=$&#123;a&#125;; b=$&#123;b&#125;`;document.body.appendChild(dom); 最后显示的HTML中就会有一个style标签，里面插入了base.css中的代码 关于css文件的几点说明： 如果是less，需要先安装less和less-loader，然后配置.less文件的loader依次是[style-loader, css-loader, less-loader] 不要忘了css本身就是有@import语句的。在一个css中引入另一个css就直接用css自带的@import即可 如果在入口js中引入多个css文件，默认情况下会创建多个style标签 关于rule的配置，还有include、exclude等更多功能，详见官方文档。关于每个loader的配置，可参见loader的官方文档。 路径别名处理通常，源代码和静态资源都放在根目录下的src文件夹中，比如上面的示例中，page1.js位于src/pages/page1.js，base.css位于src/assets/css/base.css，在page1.js中引入base.css，采用相对路径就是../assets/css/base.css。需要注意的是，在webpack中，我们只用关心打包前源代码中的相对路径关系，打包后webpack会自动解决路径问题，引入打包后的文件或资源。在这里，可以使用路径别名的方式，指定@表示src目录。只需要在webpack.config.js中配置： 12345678910const path = require('path');modules.exports = &#123; resolve: &#123; // alias配置别名 alias: &#123; // 指定@为src目录的别名 '@': path.resolve(__dirname, './src') &#125; &#125;&#125; 这样，在page1.js中就可以直接用@引用： 1import '@/assets/css/base.css' 同样，对于一些常用的模块，也可以用别名的方式。比如base.css是所有入口js文件都要加载的，那么可以直接指定： 12345678const path = require('path');module.exports = &#123; resolve: &#123; alias: &#123; 'base': path.resolve(__dirname, './src/assets/css/base.css') &#125; &#125;&#125; 这样使用时就可以直接： 1import &apos;base&apos;; postcss的使用目前为止，我们所做的也就是将css打包合并，并且使用相关的loader对less、sass等进行编译。借助postcss，可以对css进行更多的处理，比如给css3属性加上兼容性的浏览器前缀，将px单位转换成rem等等。postcss功能非常强大，它是一个基于js创造的处理css的生态系统，包含诸多插件以实现对css的各种处理。 如果要说postcss和LESS、SASS等css编译器的区别，主要有以下两个方面： LESS和SASS是要求先熟悉其语法，并按照其规定的语法规范书写，postcss也可以实现这样的功能。此外，postcss可以让你更随意的方式来写，不一定非要遵循LESS和SASS的语法规范，只要能用合适的插件来处理成标准css即可 LESS和SASS的功能postcss也都有，但postcss能做的远比LESS和SASS多。postcss更像是一个webpack这样的生态系统，借助强大的插件生态，可以实现更强大的功能。 图片资源的处理在上面例子中引入的base.css文件中，假如我们加上一张图片的引用： 123body &#123; background-image: url('../imgs/test.jpeg')&#125; 再执行npm run dev，此时webpack会报错。这是因为在这个css文件中，引用了一个后缀名为.jpeg的文件，而我们并没有在loader中指定该文件的规则。看起来很奇怪，为什么普通环境下能跑的css代码，在webpack中却出了问题呢。回想一下webpack的功能就会发现下面这两点： webpack将所有资源打包输出到dist文件夹，所以也必须将图片文件打包输出，我们在src文件夹下存放的资源和代码，并不是最后打包输出显示的资源和代码 webpack将所有文件当成模块，也会将图片当成模块。从这里可以看到，webpack中遇到任何对其他文件的依赖都需要进行处理，而不仅仅是import语句指定的依赖。 处理这个问题，就需要用到file-loader或者url-loader 1npm i file-loader url-loader -D 在webpack.config.js中配置loader： 12345678module.exports = &#123; module: &#123; rules: [&#123; test: /\.(jpe?g|png)$/, use: ['file-loader'] &#125;] &#125;&#125; 然后在运行webpack，就发现图片可以正常显示。这是因为file-loader会将指定的图片进行打包输出，返回打包后的地址url，并且对css代码中的url进行替换，从而可以正常显示。url-loader也可以实现该功能，并且url-loader可以配置一个固定的大小，并将小于该大小的图片以base64编码形式打包显示。 js的处理]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>javascript, node, webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习webpack：基础配置]]></title>
    <url>%2F2019%2F09%2F17%2F%E5%AD%A6%E4%B9%A0webpack%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[上一篇博客起了个头，介绍了为什么要用webpack，用webpack可以做什么，以及最简单地配置。这篇博客将结合实际需求，一步一步的引入一些配置，所有内容基于实际需求出发。 entry和output上一篇博客说到，entry是webpack打包的入口文件，webpack会从这个入口文件开始，寻找该入口文件的依赖模块，以及递归的寻找依赖模块的依赖模块，直到将所有的依赖模块打包成单个js文件输出到output配置的路径。根据不同的使用场景，主要有一对一、多对一、多对多等不同情况。 默认值如果没有设置entry，那么其默认值是./src/index.js，即webpack会自动寻找根目录下的src文件夹中的index.js当做入口文件 entry为字符串：一对一通过字符串值可以直接指定入口文件的路径，比如上一篇博客中的例子： 123456789const path = require('path');module.exports = &#123; entry: './src/index.js', output: &#123; path: path.join(__dirname, 'dist'), filename: 'bundle.js' &#125;&#125; 这种情况就是将一个输入文件打包到一个输出文件。 entry为数组：多对一有时为了业务逻辑更加清晰，我们的入口文件可能不止一个，这时可以将多个入口文件放在一个数组中，指定到entry： 123456789const path = require('path');module.exports = &#123; entry: ['./src/index1.js', './src/index2.js'], output: &#123; path: path.join(__dirname, 'dist'), filename: 'bundle.js' &#125;&#125; 这时会将./src/index1.js和./src/index2.js两个文件打包成一个文件输出。 entry为对象：多对多这种场景其实更常见，比如我们想做一个SPA，一共有5个page，那么每个page应该都是一个单独的入口文件，最后每个page都应该打包输出一个单独的文件，也就是5个输入、5个输出的情况。这时就要用到对象形式的entry： 123456789101112const path = require('path');module.exports = &#123; entry: &#123; index1: './src/index1.js', index2: './src/index2.js' &#125;, output: &#123; path: path.join(__dirname, 'dist'), filename: '[name].js' &#125;&#125; 在output中的filename中，我们没有直接指定文件名，而是用[name].js，这里的name就是entry中的key值index1和index2，也就是告诉webpack，对entry中的两个入口文件分别打包，最后分别输出到dist下的index1.js和index2.js。 更完美一点的用法在一个SPA项目中，有可能后面还会增加新的page，按照前面的配置，每次新加一个page，就要把这个page的路径放到entry里面去，告诉webpack把新增的这个page打包。显然这种方式并不完美，可以有更懒的办法。为了便于管理，一般会将所有的页面都放到pages目录下，那么在webpack构建时，只需要读取这个目录下的所有js文件，然后动态生成entry对象就可以了。 1234567891011121314151617181920212223const path = require('path');const glob = require('glob');function getEntries() &#123; const pagePath = path.resolve(__dirname, 'src/pages'); let entries = &#123;&#125;; // 读取pages目录下的所有js文件 let files = glob.sync(pagePath + '/*.js'); // 根据文件名，生成entry对象 files.forEach(item =&gt; &#123; let filename = item.split(path.sep).pop().split('.')[0]; entries[filename] = item; &#125;) return entries &#125;module.exports = &#123; entry: getEntries(), output: &#123; path: path.join(__dirname, '/dist'), filename: '[name].js' &#125;&#125; 这样，就可以一劳永逸，以后添加的所有页面都可以自动打包了。 输出添加hash大家都知道浏览器是有缓存机制的，如果是同一个js文件，即使服务器上已经存在更新的版本，浏览器仍有可能从本地缓存读取，从而不能拿到最新的结果。要解决这个问题，就需要让每次打包生成的js文件名不一样，然后让HTML去引用这个新名称的js文件，从而绕过浏览器的缓存。修改文件名最简单的方法就是在文件名后面加上md5戳，在webpack中这很容易实现 hash1234567modules.exports = &#123; entry: getEntries(), output: &#123; path: path.join(__dirname, '/dist'), filename: '[name].[hash].js' &#125;&#125; 只用在filename后面加上[hash]，最后打包生成的js文件名就会带上md5戳。比如： 12index1.20e52ce145885ab03243.jsindex2.20e52ce145885ab03243.js 如果不希望后面的md5戳那么长，也可以指定md5戳的长度： 1234567modules.exports = &#123; entry: getEntries(), output: &#123; path: path.join(__dirname, '/dist'), filename: '[name].[hash:5].js' &#125;&#125; 这样最后打包生成的js文件的md5长度只有5位： 12index1.20e52.jsindex2.20e52.js hash的计算方法是基于整个项目的，只要整个项目中的任何一个文件发生变化，生成的md5戳就会改变，即使真正的入口js及其依赖并没有发生变化。此外，所有的输出文件都共用这一个md5戳的值。这种方式有些过于粗暴，对浏览器的缓存机制很不友好。我们希望的是，如果文件有改动，文件名后面的hash值改变，如果没有改动，则保持不变，浏览器直接从缓存读取。这样既保证了及时更新，又保证了性能。 chunkhashchunkhash基于每个入口文件及其依赖进行计算，每个输出文件的md5戳只跟自己的依赖文件有关，所以每个输出文件的md5戳都是不同的，并且只有自己的入口文件或依赖文件发生改变时才会变化。 1234567modules.exports = &#123; entry: getEntries(), output: &#123; path: path.join(__dirname, '/dist'), filename: '[name].[chunkhash:5].js' &#125;&#125; 最后输出的结果： 12index1.f85c4.jsindex2.dd9e3.js 显然，chunkhash的方式更加理想。 动态生成HTML每次打包生成的js文件名都会不一样，那么index.html中的script标签每次都要去改引入的文件名，这也太麻烦了。同样的，webpack可以帮我们解决这个问题。前面的博客中提到，webpack的强大之处在于强大的生态系统，提供了很多有用的插件。在这里，我们就可以使用插件来帮我们实现。 首先，安装这个插件： 1npm i html-webpack-plugin -D 然后，在webpack配置文件中使用这个插件： 12345678910const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; ... plugins: [ new HtmlWebpackPlugin(&#123; // options配置 &#125;) ]&#125; 这时候再执行npm run build，就会看到dist文件下会自动生成一个index.html，并且这个Html文件会自动引入文件名变化的index.[md5].js文件。直接将这个文件拖到浏览器中就可以显示。 如果不做任何配置，html-webpack-plugin会创建一个新的空白HTML（官方文档说会默认寻找src/index.ejs，不过我在实测中未实现，有可能是我哪个地方配置不对），只是在这个HTML中引入了打包后的js文件，没有设定任何的DOM。这种情况是合理的，因为当我们用webpack时，很多时候HTML本身就是空白的，所有的DOM都是通过js渲染出来然后挂载上去的，比如常见的vue。可以通过title去设定这个HTML的title标签的内容。当然也可以指定一个模板HTML，html-webpack-plugin会在这个HTML中自动引入打包后的js文件。options的主要配置有： template：一个字符串路径，指定HTML的模板，将在该HTML中引入打包后的js filename：指定输出文件的文件名 Chunks：默认情况下，html-webpack-plugin会引入打包后的所有的js文件，可以在chunk中指定引入哪些文件 12345678910plugins: [ new HtmlWebpackPlugin(&#123; // 指定index.html作为模板，即让index.html自动引用打包后的js文件 template: 'src/index.html', // 输出到dist目录下的index1.html filename: 'index1.html', // 让index.html只引用dist目录下的page1.[hash].js文件，注意这里只用写文件名的前缀，如果写成page1.js会直接在dist文件夹下找page1.js文件，而不能找到带hash的结果 chunks: ['page1'] &#125;)] 如果希望有多个HTML，那么就可以设置多个html-webpack-plugin: 1234567891011121314plugins: [ // 第一个页面，index1.html，引用page1.js打包后的文件 new HtmlWebpackPlugin(&#123; template: 'src/index.html', filename: 'index1.html', chunks: ['page1'] &#125;), // 第二个页面，index2.html，引用page2.js打包后的文件 new HtmlWebpackPlugin(&#123; template: 'src/index.html', filename: 'index2.html', chunks: ['page2'] &#125;)] 当然，如果页面个数是动态变化的，也可以用多entry类型的形式读取文件夹下的所有文件。更多的配置可以Github 清除distwebpack每执行一次，就会在dist目录下生成一些文件。如果这次生成的文件和上次是同名的，则会直接覆盖，问题不大。但如果是不同名的，则会在dist文件中累加，最后导致dist文件夹中存在很多不必要的文件。例如上面我们加上md5戳之后，每次打包生成的输出文件名并不相同，这就会造成dist文件夹的累积。即使不是用md5戳，也会有类似场景。比如开始我在pages下有一个page3.js，打包后在dist目录下生成了page3.js，后来我不需要这个页面了，把pages下的page3.js删除了，执行webpack，但此时dist目录下的page3.js依然存在。显然这些不是我们希望的。一种解决方法是每次执行webpack前手动清空dist，不过这也太麻烦了，这种麻烦的事情当然需要webpack来替我们做。 首先，需要安装这个插件 1npm i clean-webpack-plugin 然后，在配置文件中使用这个插件 1234567const &#123;CleanWebpackPlugin&#125; = require('clean-webpack-plugin');modules.exports = &#123; ..., plugins: [ new CleanWebpackPlugin() ]&#125; 这样，每次执行webpack时就会自动清除dist目录下的所有文件。 watch模式到目前为止，每次修改js文件后，都需要手动的执行npm run build来启动webpack进行编译。同样的，这种机械性的重复工作很烦，应该交给webpack来做才对。只需要在执行webpack时加上--watch启动监听模式就可以了，直接在package.json中修改： 123"scripts": &#123; "build": "webpack --watch"&#125; 这样只需要执行一遍npm run build，后面只要我们修改了入口文件或其依赖文件中的任意一个，都会自动重新执行webpack打包。注意，如果是修改了webpack的配置文件webpack.config.js，并不会自动重新执行，还是要手动执行以下。 webpack-dev-server自动刷新虽然修改文件后可以自动打包了，但还是要手动刷新一下浏览器才能看到效果，这步操作也还是有点烦，同样的交给webpack来做吧。 单个输出我们这里先考虑只有一个输出的情况，即html-webpack-plugin为默认配置： 1plugins: [new HtmlWebpackPlugin()] 安装一下webpack-dev-sever插件 1npm i webpack-dev-server -D 在配置文件webpack.config.js中启用： 123456module.exports = &#123; devServer: &#123; // 指定dist文件夹作为服务器的目录 contentBase: './dist' &#125;&#125; 这时候，在package.json中直接通过webpack-dev-server启动 1234"scripts": &#123; "build": "webpack --watch", "start": "webpack-dev-server --opem"&#125; 然后执行npm run start，浏览器窗口就会自动打开，显示index.html引用所有js文件的结果。这是只要改变index.html或者任意一个引用的js文件，浏览器都会自动刷新以显示最新的结果。 多个输出单个输出的情况比较简单，dist目录下只有一个index.html文件，浏览器一打开就会显示这个文件。但是，如果是上面“动态生成HTML”一节描述的多个html文件，DevSever肯定无法知道显示哪一个了，这时有以下2种办法： Webpack-dev-server一般默认打开的是localhost:8080，在contentBase中我们配置的就是dist文件夹，所以这个地址等同于dist文件夹，如果输入localhost:8080/index1.html就会显示index1.html，输入localhost:8080/index2.html就会显示index2.html 直接配置openPage，告诉webpack-dev-server默认打开哪个： 12345devServer: &#123; contentBase: "./dist", // 告诉webpack-dev-server默认打开index2.html openPage: './index2.html'&#125; 热更新在已经使用了webpack-dev-server的情况下，修改文件已经不需要手动刷新了，但是，浏览器自动刷新也会有一些问题：比如在调试一个表单验证问题，已经填写了一些信息，如果浏览器自动刷新，会直接将之前填写的表单内容清空。而webpack的热更新(HMR, Hot Module Replacement)，就可以让浏览器在不刷新的情况下直接更新浏览器页面。 使用HotModuleReplacementPlugin，它包含在webpack中。在配置文件中添加： 12345const webpack = require('webpack');module.exports = &#123; plugins: [new webpack.HotModuleReplacementPlugin()]&#125; 在之前devServer中设置hot为true 1234devSever: &#123; contentBase: './dist', hot: true&#125; 在入口文件index.js底部添加对子模块的监听 123if (module.hot) &#123; module.hot.accept();&#125; 这样，如果再修改子模块a.js中的文件时，在不刷新浏览器的情况下就可以更新。 Devtool调试到目前为止，都是介绍如何用webpack打包从而进行开发，却忽视了一个问题于webpack将多个文件打包成了单个文件的。最后在浏览器中，我们能看到的也就是打包后的这个文件。如果是打断点调试，我们当然希望是能在打包之前原始模块中，这样定位问题和修改也比较方便。为了实现这个功能，webpack中提供了devtool配置，只需要设置如下： 123module.exports = &#123; devtool: 'source-map'&#125; 这样，在浏览器的控制台中就可以看到打包之前的原始模块文件。 mode通常，js代码都要分开发模式和生产模式。比如，在开发模式中，不用太纠结代码的性能，更加重视代码的可读性，而在生产模式中，代码一般需要进行优化和压缩等。在webpack4中，可以通过mode来配置development模式和production模式，主要有两种配置方法： 直接在配置文件中指定mode 123module.exports = &#123; mode: 'development'&#125; 在运行webpack时增加--mode，可以在package.json中添加 1234"scripts": &#123; "dev": "webpack --mode development", "prod": "webpack --mode production"&#125; 这时，运行npm run dev就是开发模式，npm run prod就是生产模式 分别看一下dist目录下输出的文件，可以发现production模式下的代码体积更小，dev模式下的代码可读性更强。 多配置文件在webpack 4中，已经可以通过mode来指定不同生产环境下代码的编译模式了，但这还是不够的。比如，在开发环境下，我们希望开启devtool调试，而在生产模式下就不需要。像这样的区分配置还有很多，如果每次都是去修改webpack.config.js，显然非常麻烦。一种简单的方法是，我们建一个build文件夹，在这个文件下下放三个配置文件。为了整合，先安装一个叫webpack-merge的插件，其主要作用是合并两个webpack配置文件： 1npm i webpack-merge -D 然后分别写三个配置文件： webpack.base.config.js：这个文件用来存放公共的配置，也就是在开发环境和生产环境都要用到的 123module.exports = &#123; // 公共配置，如entry/output&#125; webpack.dev.config.js：开发环境下的独有配置 123456789101112const merge = require('webpack-merge');const baseConfig = require('./webpack.base.config')module.exports = merge(baseConfig, &#123; mode: 'development', devtool: 'source-map', devServer: &#123; contentBase: './dist', // 在开发模式下，默认打开index1 openPage: './index1.html', hot: true &#125;,&#125;) webpack.prod.config.js：生产环境下的独有配置 123456789101112const merge = require('webpack-merge');const baseConfig = require('./webpack.base.config');module.exports = merge(baseConfig, &#123; mode: 'production', devServer: &#123; contentBase: './dist', // 在生产模式下，默认打开index2 openPage: './index2.html', hot: true &#125;,&#125;) 可以看到，base只是一个公共文件，真正传到webpack使用的是dev和prod。那么如何传到webpack呢？在webpack或者webpack-dev-server运行时，可以通过--config指定配置文件。所以，我们直接修改package.json 1234"scripts": &#123; "dev": "webpack-dev-server --open --config ./build/webpack.dev.config.js", "prod": "webpack-dev-server --open --config ./build/webpack.prod.config.js"&#125; 此时，执行npm run dev，就会按照webpack.dev.config.js的配置，打开index1.html，并且开启debug；执行npm run prod，就会按照webpack.prod.config.js的配置，打开index2.html。]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>javascript, node, webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习webpack：从最简单的webpack说起]]></title>
    <url>%2F2019%2F09%2F16%2F%E5%AD%A6%E4%B9%A0webpack%E4%B9%8B%E4%BA%8C%EF%BC%9A%E4%BB%8E%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84webpack%E8%AF%B4%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[看了很多webpack的教程，大多是上来就讲一堆配置，一堆插件的使用。这种文章看起来有点类似于官方文档，或者新华字典。我想回归初心，换一种方式，基于实际使用出发，一步一步介绍webpack。 从一个最简单的例子开始，这个例子只为了描述最简单的webpack功能，实现一个最简单的需求：在浏览器上显示一段文字。 传统方式首先我们有一个index.html，这个html中只是引入了index.js，a.js和b.js。 123456789101112&lt;!Doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta name="charset" content="utf-8"&gt; &lt;title&gt;webpack&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript" src="./a.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="./b.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="./index.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在a.js中声明了变量var a = 1;，在b.js中声明了变量var b = 2;。由于这种方式下，作用域是共享的，a和b相当于都是挂载在window上，所以在index.js中可以直接访问到a和b的值。 在index.js中，我们创建一个DOM并挂载到HTML上： 123var dom = document.createElement('p');dom.innerHTML = `a=$&#123;a&#125;; b=$&#123;b&#125;`;document.body.appendChild(dom); 最后，在浏览器上就会显示a=1; b=2。 这种使用方式虽然简单，但是会有潜在的问题： 浏览器在加载时，会先加载html文件，然后根据HTML里面的script标签去依次加载每个js文件。这样对于每个js文件，浏览器都会向服务器发送一次请求。如果引入的文件数很多，那么发送的请求次数就会过多，对服务器造成一定的压力。而且，单个文件可能并不大，相对于浏览器对每次请求都需要建立链接、断开链接的成本来说很不划算。要解决这个问题，就需要打包，将多个js文件打包成单个。 不能严格保证js文件的加载顺序，比如index.js加载完了，但它所依赖的a.js还没加载。当然，这个问题可以用require.js解决。 不同script标签引入的js代码，会污染全局作用域，比如a.js中声明的a就直接挂载到了window上，其他文件中如果再声明a变量，就会有冲突。这个问题可以用立即执行函数的方式解决。 虽然有办法解决，但总感觉不是那么完美，治标而不治本。回归到js的运行环境上，这都是因为js代码需要在浏览器中运行。如果是在node环境中运行，那可以直接使用CommonJS规范，每个文件就是一个模块，各个模块之间的作用域是独立的，通过require可以解决模块依赖和加载问题。甚至还可以在node中利用ES6的模块机制，也同样可以解决这个问题。显然，这种写代码的方式要简单很多，但只能在node环境下。而webpack的一个重要作用，就是可以让你这种方式写出来的代码能在浏览器中运行。 webpack方式a.js和b.js分别作为2个模块，通过ES6的export导出变量a和b，在index.js中通过import引入： 123456789101112//a.jsexport var a = 1;//b.jsexport var b = 2;//index.jsimport &#123;a&#125; from './a.js';import &#123;b&#125; from './b.js';var dom = document.createElement('p');dom.innerHTML = `a=$&#123;a&#125;; b=$&#123;b&#125;`;document.body.appendChild(dom); 最后，我们希望用webpack，将其打包成一个单独的文件，直接挂载到index.html中。从零开始，安装webpack。 新建一个文件夹，在这个文件夹中npm init，初始化。 安装webpack和webpack-cli，运行npm install webpack webpack-cli -D。webpack-cli为webpack提供了命令行工具，让我们可以直接在命令行中使用webpack 建立src文件夹，将a.js,b.js和index.js存放在src文件夹下。这个文件夹存放的是原始文件 建立dist文件夹，用来存放编译后的文件，也就是打包后的单个文件 将index.html放到src文件夹下，这时引用的不是index.js，而是打包后的位于dist目录下的bundle.js文件 1&lt;script type="text/javascript" src="../dist/bundle.js"&gt;&lt;/script&gt; 配置webpack。webpack的配置就是在根目录下直接新建一个webpack.config.js，配置如下： 123456789const path = require('path');module.exports = &#123; entry: './src/index.js', output: &#123; path: path.join(__dirname, 'dist'), filename: 'bundle.js' &#125;&#125; entry是打包的入口文件，也就是告诉webpack打包哪个文件，这里指定的是index.js。由于在index.js中import了a.js和b.js，所以webpack在打包时会同时将a.js和b.js引入。从这里可以看到，只用告诉webpack入口文件即可，所有的依赖文件webpack会自己寻找和解决。 output是告诉webpack，打包后的文件放哪里。path指定了打包后的文件路径，filename指定了打包后的文件名。综合起来，打包后的文件就是dist目录下的bundle.js 在package.json中的script下做个配置： 1234"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "build": "webpack" &#125;, 直接运行npm run build，node就会自动执行webpack，这时在dist目录下就可以看到生成的js文件（只有一个），将index.html放到浏览器中，就会看到最后显示的效果。 不止于此从上面的例子看到，使用了webpack之后，我们解决了传统方式里面遇到的各种问题。当然，webpack能做的，远不止这些。比如在写代码时，可能还会有这些需求： 代码转换：将 TypeScript 编译成JavaScript、将 SCSS 编译成 CSS等。 文件优化：压缩JavaScript、CSS、HTML 代码，压缩合并图片等。 代码分割：提取多个页面的公共代码，提取首屏不需要执行部分代码让其异步记在。 模块合并：在采用模块化的项目里会有很多个模块和文件，需要通过构建功能将模块分类合并成一个文件。 自动刷新：监听本地源代码变化，自动重新构建、刷新浏览器。 代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。 自动发布：更新代码后，自动构建出线上发布代码并传输给发布系统。 我们需要一个工具来帮我们解决这些问题，完成整个构建流程。使用构建工具的目的，是为了让我们写代码更加方便，可以用更新的特性而不用过多关心浏览器的兼容问题；让我们可以省去很多机械重复性的工作，比如修改代码后浏览器会自动刷新，提高我们的开发效率。 当然，在webpack之前，已经有很多优秀的构建工具了，比如grunt、gulp等。称webpack是当下最流行的构建工具毫不为过。webpack强大不仅在其本身，还在于很多基于webpack的插件，提供了一个强大的生态系统。webpack能做的事情还有很多，将在后面一步步继续学习。]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>javascript, node, webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文字处理之二：换行及word-break和word-wrap属性]]></title>
    <url>%2F2019%2F08%2F29%2F%E6%96%87%E5%AD%97%E5%A4%84%E7%90%86%E4%B9%8B%E6%8D%A2%E8%A1%8C%E5%8F%8Aword-break%E5%92%8Cword-wrap%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[上一篇博客中介绍white-space属性时聊到了换行，这一篇介绍换行的细节。 浏览器的默认行为浏览器的换行行为，对于中文和英文存在一些差别。 中文换行正如上一篇博客中所说的，中文换行比较简单，这一行放不下就换行。除了中文之外，韩文和日文的处理也是一样的。这三种文字合在一起就是MDN介绍word-break属性时所说的CJK（Chinese, Japanese, Korean的缩写）。 英文换行来到英文，情况就要复杂一些。在英文中有单词的概念，所以在换行时就得考虑单词的完整性。 浏览器按照空格来识别单词，默认情况下，浏览器不会在单词内换行 1&lt;p&gt; thisisalonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglongword&lt;/p&gt; 我们在p标签内部放了一些英文字母，这些字母之间并没有用空格来分隔开来，这就像文言文没有用标点符号断句一样。所以，就如同你看不懂没有断句的文言文，浏览器也看不懂没有用空格分隔的英文。于是浏览器在处理时，就会把这一长串英文只是当成一个很长很长的单词，只有一个单词也就不会换行，因为默认的换行只会在单词之间。 当一行放不下时，浏览器会尝试把最后一个单词放到下一行，如果下面这一整个空行还是放不下这个单词，那么就会任由这个单词超出容器，反正默认情况下浏览器是不会把单词拆开的。 1&lt;p&gt; this is a longlonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglongword&lt;/p&gt; 最后显示时，就会把后面这个长单词放到下一行，然后任由其超出容器： word-break属性从上面的两点看到，浏览器已经在很努力的换行，从而尽量让文字不要超出容器了。但即使是这样，对于较小的容器中存放的长单词，当整个一行还放不下一个单词是，浏览器也是无能为力，毕竟浏览器要保证单词的完整性，不敢随随便便把一个单词给拆了。但是，word-break属性就赋予了浏览器拆单词的权力。 word-break:normal：这是默认值，也就是浏览器的默认行为 word-break:break-all：能把all都break掉，所有的东西都能拆，所以，单词随便拆 1&lt;p style="word-break:break-all"&gt;this is a longlonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglongword&lt;/p&gt; 这样浏览器在排版时，就完全可以把字母当成拆分单位，一个字母一个字母的往上放，放不下时就把字母放到下一行。可以理解成，此时就没有单词的概念了，只有字母。 word-break:keep-all：上面在介绍浏览器的默认行为时，CJK字符和英文是分开，之所以这样，是因为word-break属性对于中英文的行为也是分开的。上面介绍的break-all值，主要也是针对英文的，汉字还是按照浏览器的默认行为，装不下就换行。对于中文来说，没有拆分不拆分，只有换行不换行。keep-all就是让中文不要换行，此时英文还是按照浏览器的默认行为来。 1&lt;p style="word-break:keep-all"&gt;this is a longlonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglongword 这是中文这是中文是中文这是中文这是中文这是中文是中文这是中文这是中文这是中文是中文这是中文这是中文这是中文是中文这是中文这是中文这是中文是中文这是中文这是中文这是中文是中文这是中文这是中文这是中文是中文这是中文&lt;/p&gt; 注意这里我在中英文之间加了个空格，否则浏览器会把后面的中文页当成是英文单词的一部分。最后显示时，英文还是按照默认行为，中文变成了不换行。 word-break:break-word：在MDN上，只会介绍前面三个属性，因为只有前三个才是标准的，而break-word是非标准的。如果一定要使用这个值，就需要注意下浏览器的兼容性，其最后显示的效果，跟下面介绍的word-wrap:break-word基本一致，这里不再多说，看下面吧。 word-wrap属性word-break:break-all在拆英文单词时，细看一下，当longlonglon...longword这个单词在第一行末尾放不下时，其实是分了两步： 以字母为单位处理，尽量将这个长单词的字母往第一行放，能放多少放多少 后面连单个字母都放不下时，再换行，放其他字母。 而word-wrap:break-word则不同，他会首先直接换行，放单词，第二行放不下，再拆单词 1&lt;p style="word-break:break-word"&gt;this is a longlonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglongword&lt;/p&gt; 与上面的word-break:break-all的图对比一下就明白了，拆单词也是拆单词，只不过我先换到下一行再拆。 另一个属性值是word-wrap:normal，这就是默认值，对应浏览器的默认行为。 word-break与word-wrap很容易弄混，所以在CSS3中，word-wrap已经改成了overflow-wrap，不过考虑兼容性，还是用word-wrap的比较多。 总结一下word-break:break-all与word-wrap:break-word这两个属性，都是考虑拆英文长单词的，但是拆分的方法有点不一样。另外word-break:keep-all还可以控制中文。其实想想，还是中文的事少，没有拆分的顾虑，只用考虑换行不换行就可以了。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML, CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文字处理之一：空白字符及white-space属性]]></title>
    <url>%2F2019%2F08%2F28%2F%E6%96%87%E5%AD%97%E5%A4%84%E7%90%86%E4%B9%8B%E7%A9%BA%E7%99%BD%E5%AD%97%E7%AC%A6%E5%8F%8Awhite-space%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[p标签中插入一段文字，是非常常见的需求，但是仔细分析，这里面有很多需要注意的细节。这篇和下篇博客，主要讲对于文本内容显示的处理，这篇主要介绍空白字符和white-space属性。 浏览器的默认行为浏览器支持4种空白字符：空格、制表符、回车、换行。默认情况下，有以下几点： 所有的空白字符，都会当成空格处理 12&lt;p&gt;Hello World&lt;/p&gt; hello world之间加了一个换行符，但是最后显示的效果如下： 插入的是换行符，但是最后显示的时候变成了空格。这也就说明，如果我们有两段文字，在一个p标签内并不会保留换行符。要想实现换行效果，要么用两个p标签，要么用&lt;br/&gt;来换行。 头尾的空白符会直接忽略 1&lt;p&gt; hello world &lt;/p&gt; 在头部和尾部都有空格，但最后显示时，两边的空格会直接忽略。如果头尾是换行，也会被忽略掉。为什么要这样做呢，比如我们写代码的时候，为了结构清晰通常喜欢排版一下： 1234&lt;p&gt;&lt;!-- 这里有第一个换行符 --&gt; &lt;span&gt;hello &lt;!-- hello前后加空格也会被忽略 --&gt;&lt;/span&gt;&lt;!-- 这里的换行符会被当成空格 --&gt; &lt;span&gt;&lt;!-- world前后加空格也会被忽略 --&gt; world&lt;/span&gt;&lt;!-- 这里有第二个换行符 --&gt;&lt;/p&gt; 最后的显示效果如下： p标签内部首尾的两个换行符都会直接忽略，使得我们排版带来的空白字符就不会影响最后显示的效果。span标签内部首尾的空格也会被忽略，所以，不要指望在span包裹的hello之后和world之前加入空格来增加两者间距。 多个空格会被合并 这一点应该比较熟悉，我在hello和world之间插入100个空格，也只会显示一个而已。那么如果我想插入多个空格呢，就只能用到字符实体这种东西了，也就是&amp;nbsp;。 12&lt;p&gt;Hello World&lt;/p&gt;&lt;p&gt;Hello &amp;nbsp;&amp;nbsp;&amp;nbsp; World&lt;/p&gt; white-space属性浏览器的这种默认行为，为我们提供了很多便利，也符合我们的日常需求，比如代码的排版不会对展示产生过多影响。但是，这种默认行为也并不总是符合我们的需求。如果需要改变，可以通过white-space属性来实现，顾名思义，这个属性就是控制空白字符的，同时，他也会对浏览器的默认换行行为有一些影响。 white-space:normal，这是默认值，也就是浏览器的默认行为。除了上面提到的空白字符的处理外，当文字在一行放不下时，浏览器还会自动换行。关于换行的具体细节在下一篇博客介绍，这里我们简单点，只考虑中文字符，字数多了放不下就换一行。 1&lt;p&gt;文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多&lt;/p&gt; 最后显示的效果如下： white-space:nowrap：所谓wrap，翻译成中文就是包裹，在CSS里面，我们可以理解成当一行放不下时，为了让他不超出容器，浏览器就要给文字换行，将文字包裹起来。那么nowrap就是不包裹，也就是文字超出就超出吧。 1&lt;p style="white-space:nowrap"&gt;文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多&lt;/p&gt; 最后显示的效果如下： white-space:pre：我希望我写的格式就是最终展示的浏览器，浏览器不做任何处理，那就用这个值，或者用&lt;pre&gt;标签也一样的效果 1234567&lt;p style="white-space:pre"&gt; 文字有点多文字有点多 文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多 文字有点多文字有点多文字有点多文字有点多文字有点多&lt;/p&gt; 最后显示的效果如下： 我在开头加的空格没有被忽略，中间加的换行符也没有被当成空格，甚至多个换行符也没有被合并，第二行超长了也没有自动换行。总之，浏览器没有做任何处理。 white-space:pre-wrap：pre的效果看来有点太粗暴了，我还需要wrap包裹一些，也就是在pre的基础上希望自动换行。 1234567&lt;p style="white-space:pre-wrap"&gt; 文字有点多文字有点多 文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多 文字有点多文字有点多文字有点多文字有点多文字有点多&lt;/p&gt; 最后显示的效果如下： white-space:pre-line：line是一行的意思，加上line代表我更加强调换行，所以我就保留换行符，并且保留浏览器的wrap换行，这两个都是跟换行相关的。空格还是该合并合并，该忽略忽略，不跟pre一样搞了。 1234567&lt;p style="white-space:pre-line"&gt; 文字有点多文字有点多 文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多文字有点多 文字有点多文字有点多文字有点多文字有点多文字有点多&lt;/p&gt; 最后显示的效果如下： 总结一下这个属性其实控制的是三点： 换行符是否当成空格处理 多个空格是否合并，收尾空格是否忽略 是否自动换行 每个属性对应的行为也就是下面的表 换行符 空格符的合并及忽略 自动换行 normal 当成空格，并且合并 合并 是 nowrap 当成空格，并且合并 合并 否 pre 保留 保留 否 pre-wrap 保留 保留 是 pre-line 保留 合并 是 关于换行，也还是有很多细节的，下一篇详聊~]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML, CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端适配之三：使用meta标签设置viewport]]></title>
    <url>%2F2018%2F12%2F28%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E4%B9%8B%E4%B8%89%EF%BC%9A%E4%BD%BF%E7%94%A8meta%E6%A0%87%E7%AD%BE%E8%AE%BE%E7%BD%AEviewport%2F</url>
    <content type="text"><![CDATA[前两篇博客，把像素和viewport的概念讲清楚了。现在开始，用meta标签来设置viewport。 meta标签meta标签里面的内容，主要是提供关于这个HTML页面的元信息的。简单点说，就是你用这些信息来告诉浏览器，应该如何解析这个HTML文件。比如 1&lt;meta charset="utf-8"&gt; 这个标签是告诉浏览器，该HTML文件的字符编码格式是utf-8。当浏览器解析该HTML文件时，由于meta标签位于头部，会先获取到这个信息，然后浏览器就用这个utf-8编码来解析这个HTML文件中的字符。 当然，除了上面这种简单的格式外，meta标签更常见的是这种name + content的形式： 1&lt;meta name="format-detection" content="telephone=no" /&gt; name属性的值告诉浏览器，这个meta标签设置的是format-detection，其具体值是content中的telephone=no，即忽略将数字识别成电话号码。 viewport的设置上一篇博客的最后已经提到，我们所做的适配，就是要调整layout viewport的大小，而用meta标签就可以调整layout viewport的大小。上网去搜移动端适配，一定会看到下面这句代码： 1&lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; 先介绍一下这几个属性： 属性名 说明 width 设置layout viewport的宽度，为一个正整数，或字符串width-device initial-scale 设置页面的初始缩放值，为一个数字，可以带小数 minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数 maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数 height 设置layout viewport的高度，这个属性对我们并不重要，很少使用 user-scalable 是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许 target-densitydpi 值可以为一个数值或 high-dpi 、 medium-dpi、 low-dpi、 device-dpi 这几个字符串中的一个。安卓中支持，当 target-densitydpi=device-dpi 时， css中的1px会等于物理像素中的1px。 回到应用场景，我们用这个标签的主要目的是做移动端的适配，一般都是做一个专门为移动端设计的页面。所以，我们在设置layout viewport时，当然希望这个viewport的尺寸等于ideal viewport。 需求已经明确了，接下来看看我们如何利用上面表里的属性来实现。 利用width1&lt;meta name="viewport" width="device-width"&gt; 这个width，就是用来设置layout viewport的宽度。我们设置其值为device-width，也就是设置成设备的实际宽度。而ideal viewport的宽度是与设备的宽度相等的，所以，这句代码就把viewport设置成了ideal viewport的大小。可以分别用window.innerWidth和document.document.clientWidth查看： 当然，只要你高兴，也可以设置成别的值，比如把宽度设置成1000，那么layout viewport就会比visual viewport大，浏览时会有一个滚动条。具体实现时，代码上最好加上initial-scale=1.0，防止浏览器对页面进行缩放。 利用scale1&lt;meta name="viewport" initial-scale="1.0"&gt; Initial-scale用来设置初次加载页面时layout viewport相对于ideal viewport的大小。具体计算公式是： 12layout viewport = ideal viewport / scalescale = ideal viewport / layout viewport 需要注意的是，利用scale设置，无论计算出来的layout viewport的值大小如何，最后都会被浏览器自动缩放到与visual viewport大小相等，并不会出现滚动条。具体看下面的例子，我们设置的红框大小为100x100px，字体大小为32px。 initial-scale=1.0设置scale值为1.0，那么layout viewport的大小与ideal viewport大小相等： 此时红框显示出来的大小就是100px，字体大小也就是32px。 initial-scale=0.5设置scale值为0.5，那么layout viewport的大小就是ideal viewport的两倍，即750px： 但是浏览器会把layout viewport进行缩放，从而达到与visual viewport大小适配。对于已经是visual viewport750px的layout viewport，需要缩放到以前的0.5倍，才能正好适配375px。所以，100px的红框看起来只会有50px的大小，字体也会对应的缩小一半。如果设计图的大小是750px，那么样式大小完全可以按照设计图来写，最后只要设置scale为0.5，视觉上的效果就是缩小后的。 这里用window.innerWidth打印出来的visual viewport大小不对，用screen.width打印出来是对的，具体原因网上也没查到。有知道的同学欢迎在评论区留言~ initial-scale=2.0设置scale的值为2，那么layout viewport的大小就是ideal viewport的一半，即188px： 同样的，浏览器会自动缩放。本来是188px的layout viewport，需要放大两倍，才能填满visual viewport。此时，100px的红框会被放大成200px，字体大小会放大到64px。 同时使用width和scale两种方式都可以实现，但是兼容性不同。我们的目的，是为了把layout viewport设置成ideal viewport的带下。为了能兼容所有的设备，就有了下面的方案： 1&lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; 如果两者设置的大小不一样，那么会取较大者。设置width为device-width，然后再设置缩放值为1，就完全限制了layout viewport的大小为visual viewport了。其他的属性，都是来控制缩放的。其实，设置了maximum-scale=1.0, minimum-scale=1.0就相当于设置了user-scalable=no了。如果不禁用缩放，那么layout的viewport的大小在缩放时还是会变的。 小结用viewport的目的，是为了设置layout viewport的大小，从而保证能在移动端设备上合适的显示出来。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>HTML, CSS, 移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端适配之二：visual viewport、layout viewport和ideal viewport介绍]]></title>
    <url>%2F2018%2F12%2F27%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E4%B9%8B%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8meta%E6%A0%87%E7%AD%BE%E8%AE%BE%E7%BD%AEviewport%2F</url>
    <content type="text"><![CDATA[上一篇博文，可算把像素这个东西讲清楚了。在这篇博文里面，将继续介绍viewport相关的内容。 很多博客都会提到PPK所讲的三个viewport，有的讲的比较复杂，看的云里雾里，我这里也大概介绍一下，三个viewport主要是相对于移动端而言的。 visual viewport这个是浏览器给我们用的、能真正用来显示网页内容的区域，可以通过下面的js命令获取： 12window.innerWidthwindow.innerHeight 正如上篇博客所说的，前端里面能获取到的像素基本上都是CSS像素，所以这个的单位也是CSS像素。对于iPhone X，浏览器全屏状态下，其window.innerWidth的值为375。 上篇博客中还提到screen.width和screen.height，主要是用来获取整个屏幕的大小的，而window.innerWidth和window.innerHeight只是获取浏览器可用显示区域的大小，也就是浏览器中间负责显示的部分。当浏览器全屏时，要去掉状态栏、标签栏、任务栏等区域，当浏览器非全屏时，其值更小。由于在移动端，浏览器一般都是全屏的，所以大多数情况下screen.width与window.innerWidth的值相等，也有的博客中说用screen.width和screen.height来获取visual viewport的大小，就是这个原因。 visual viewport是我们可以直观看到的，不严谨的说，就是差不多等于手机屏幕的大小，偏向于一个物理概念。 layout viewport网页最早是出现在电脑上的，上一篇博客中提到，电脑的物理像素可能比手机还要低，但是电脑的设备无关像素（或者说是分辨率吧，更严谨一些）是明显大于手机的设备无关像素的，毕竟电脑的屏幕尺寸远比手机大啊。那些在电脑上的网页，如果没有经过专门的优化，直接搬到手机上看，那么问题就来了，网页会被挤得变形，相信这种问题大家都遇到过。所以呢，手机厂商为了解决这个问题，设置了一个layout viewport。 这是一个虚拟的窗口，其大小比手机屏幕大，加载网页时，直接把HTML渲染在这个虚拟的窗口中，这样就不会样式错乱了。在查看的时候，毕竟手机的visual viewport小啊，那就只能通过滚动条来看了。 做个比喻，layout viewport就是一张大白纸，HTML的内容就写在这个大白纸上，visual viewport就是一个放大镜，上下左右移动，可以显示其中的一部分。 Layout viewport的大小可以通过document.documentElement.clientWidth和document.document.clientHeight，实际使用中可能会有一些兼容问题，这跟DOCTYPE声明有关。不同浏览器默认的layout viewport大小不同，常见的有980px、1024px。 ideal viewportLayout viewport是为了能将电脑上的网页正确的显示到手机上。当浏览器拿到一个网页时，首先会渲染到这个layout viewport里面。可是现在有很多网页会针对手机做专门的设计，比如现在的一些H5活动页，设计的尺寸就是在手机上看的。此时如果还是把网页渲染到这个大的layout viewport上，实在是有点不合适了。所以，还应该有个ideal viewport，这个ideal viewport应该与手机屏幕大小的相同，确切来说，等于visual viewport的大小。把页面渲染到这个ideal viewport里面，就能在visual viewport中完美显示。 小结根据我的理解小结一下： 首先，我们可以假想，layout viewport和ideal viewport都是用来渲染页面的两个盒子，HTML页面渲染在盒子里面，而visual viewport用来查看渲染后的结果的，相当于一个窗口。我们设置HTML的body为width:100%，那么盒子有多宽，HTML页面就有多宽。layout viewport用来渲染电脑上的页面，所以比较大，而ideal viewport较小，用来渲染专门针对手机设计的页面。 然而，在浏览器的实现中，其实并没有那么多盒子。就只有一个layout viewport的盒子，页面就渲染在这个盒子中。layout viewport默认是比较大的。如果我们希望渲染到ideal viewport的盒子里面，那就只要调整这个layout viewport的大小即可，具体如何调整，将在下一节中介绍。 综上，layout viewport用来承载HTML的渲染，visual viewport是查看渲染结果的窗口，而ideal viewport可以理解成是一种尺寸，其大小等于visual viewport。调整layout viewport的大小，让其在visual viewport的查看下有最佳效果，就是我们想要的移动端适配。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>HTML, CSS, 移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端适配之一：到底什么是像素]]></title>
    <url>%2F2018%2F12%2F24%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E5%83%8F%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[最近在做移动端的开发，深入了解了下移动端适配的一些问题，加上自己的理解，记录下来，写一个小的系列博客，与大家分享。所有的问题，就开始从像素说起吧~ 像素是一个经常提到的概念，写CSS的人都经常会用到px作为单位。但是，在移动端，看着分辨率高达1125x2436的iPhone X，在控制台中却只有375x812的分辨率，似乎有点不合逻辑。这些问题，都将在下面找到答案。 一切都是点经常用像素来描述分辨率，比如图片的分辨率、视频的分辨率、显示器的分辨率、手机的分辨率等。不论是那种分辨率，用像素作为单位，其实就是用点的个数作为单位，一个像素，就是一个点，或者说是一个很小的正方形。 屏幕中的分辨率任何显示设备，如电脑显示器和手机屏幕，其实都是由很多个小点组成的。比如，我的显示器分辨率是1920x1080，就表示显示器横向一共有1920个像素点，纵向一共有1080个像素点，每个像素点都可以单独显示一种颜色。于是，所有像素点显示的颜色加起来，就是我们最后看到的效果。 至于每个像素点是多大，这就跟显示器硬件的性能有关了。需要注意的是，屏幕大小和分辨率的高低并无直接关系： 相同大小的屏幕，分辨率并不一定就相同 屏幕大的显示设备，分辨率并不一定就高，如iPhone X的分辨率高达2436×1125，就比我用的21英寸显示器的1920x1080的分辨率还要高 现在常常会提到4K显示器，就要求屏幕的横向分辨率达到约4000像素，如3840x2160或4096×2160。很明显，对于大小相同的屏幕，分辨率越高，像素点越多，每个像素点也就越小，成本也就越高。但是，分辨率高的最直观感受，就是可以看更高清的图片和视频，显示会更加清晰。 图片和视频中的像素与上面类似，图片和视频中的分辨率，也是描述横向和纵向分辨有多少个像素点。每个像素点表示一种颜色，所有颜色显示出来，就是一张图片。理论上，可以用数字完全描述一张图片，如下面的例子： 12345#ddfd23, #234862 ..... #fab421#ddfd23, #234862 ..... #fab421......#ddfd23, #234862 ..... #fab421#ddfd23, #234862 ..... #fab421 每个像素点上的颜色，都用一个色值表示，如果图片分辨率为400x300像素，那么横向就有400个值，纵向是300个值。 物理像素与设备独立像素对于一台显示器或手机，其实是有2个分辨率的，这两个分辨率是不同的，但也是相关的。 概念上面所解释的屏幕中的分辨率，其实都是物理像素，也就是厂家在生产显示设备时就决定的实际点的个数。上面提到，对于不同的设备而言，物理像素点的大小是不一样的，这样就会带来问题：举个例子，21英寸显示器的分辨率是1440x1080，5.8英寸的iPhone X的分辨率是2436×1125，我用CSS画一条线，其长度是20px，如果都以物理像素作为度量单位，那么在显示器上看起来正常，在iPhone X屏幕上就变得非常小，不是我们想要的结果。所以呢，为了解决这个问题，还需要一个新的度量单位，这个度量单位必须是与设备无关的，采用这个单位，无论在何种设备上，相同长度的线看起来都应该差不多，这就是设备独立像素(device-independent pixels, dips )。我们在CSS中用的CSS像素，其实就是一种设备独立像素，在Android或IOS开发中，人家就不能叫CSS像素了，不过意思还是一样滴~ 物理像素可以理解为硬件设备，设备独立像素可以认为是程序员控制显示器的接口，中间会经过操作系统来将设备独立像素转换成物理像素，用实际的物理像素点来显示。所以，在编程中能获取到的都是设备独立像素，如CSS中的获取的所有像素都是设备独立像素，而物理像素对于程序员来说是透明的，咱没法在代码中看到的。至于怎么看，将在下文介绍。 物理像素是在出厂时就决定的，但是设备独立像素其实是可调的。大家用电脑的时候，应该都试过调整分辨率，此时调整的实际就是设备独立像素，比如Macbook可以这样调整分辨率：https://support.apple.com/kb/PH25175?locale=zh_CN 在设备中查看厂家在宣传自己的产品时，往往会拿物理像素说话，因为物理像素才会代表其工艺水平，才会吸引用户花更多的钱去买。对于物理像素，一般在产品的官网参数里面都可以看到，也可以在属性中查看。如对于我的Mac笔记本，在关于本机-&gt;显示器中可以看到如下的信息，其物理分辨率大小为2560 x 1600： 要查看显示器的设备独立像素，作为写前端的人，打开浏览器，再打开控制台，敲一下代码： 12screen.widthscreen.height 对于我的Mac，得到的值为1440 x 900。对于手机，物理像素可以在手机说明书或者官网的参数配置中查到，而设备独立像素打开控制台选择对应机型后就可以看到： 当然，也可以在控制台中用上面的js命令查看。此外，这里也提供一个网站：https://material.io/tools/devices/，但是貌似国内手机没收录，具体的机型，大家可以自行百度下，基本都可以查到的。 不管何种设备，一般都满足：设备独立像素 &lt;= 物理像素 关系1window.devicePixelRatio = 设备物理像素 / 设备独立像素 通过window.devicePixelRatio，可以知道一个设备独立像素用几个物理像素点来表示。如iPhone X中，devicePixelRation为3，iPhone6/7/8中devicePixelRatio的为2。当然，devicePixelRation并不一定是整数，也有可能是1.5，2.25这些小数值。 经过我的实际测试，在手机模式下，上面这个公式基本都是成立的，而在电脑显示器上，还有些问题。另外，当我调整电脑显示器的分辨率时，无论调整出来的电脑显示器分辨率为多少，在我的MacBook上，devicePixelRation的值都为2（理论上，调整电脑显示器的分辨率，即调整了设备独立像素，而物理像素是固定的，所以devicePixelRation的值会跟着改变猜对）。经查，这可能是devicePixelRation在不同平台的定义不同造成的，所以目前，在移动端可以放心的用，在PC端还是慎用。 缩放说完上面的概念，也许会有个疑惑：有一张400x300的图片，分别放到400x300和800x600的显示器上全屏显示，会怎么样呢？ 先来看400x300的显示器，由于是全屏显示，正好图片也是400x300的分辨率，两者相等，于是很愉快的，显示器上一个像素点就显示照片上的一个像素，整个图片完美的显示出来了 而在800x600的显示器上全屏时，图片上点的数目不够用了，这时，屏幕上的4个像素点只能显示照片的一个像素点（为什么是4呢，因为一个像素点可以看成是一个正方形，横向和纵向都是2倍，所以2x2=4）。由于像素已经是最小的单位了，不能再往下分了，所以就只能就近取色，所以最后的图片看起来就会模糊。 这个原理与Retina屏幕显示是一样的。比如，对于一幅400x300的图片，用CSS设定其宽高为400x300，CSS设定的是设备独立像素。在普通屏幕上，CSS指定的400x300像素大小区域正好是400x300个物理像素点，图片完美显示，对应上面的情况一；在Retina屏上，devicePixelRatio为2，CSS指定的400x300像素大小区域有800x600个物理像素点，对应的就是上面的情况2，所以就会有模糊的情况。具体原理可以参考下面的图（来自网络）： 为了解决Retina屏幕的显示问题，往往会用更高分辨率的图片来代替，比如对于上面的情况，如果用800x600的图片，那么在Retina屏幕上显示就会非常完美，但是换到普通屏幕上，问题又来了：显示器上的一个物理像素点要显示照片上的4个像素点，装不下了。这时候，会自动下采样。下采样之后的，看起来也不会有太大问题，但可能会有点色差或者缺少锐利度。 CSS的单位你可能在有的博客上看到，一个像素的长度是一英寸的1/96。这种解释，貌似给了像素这个比较抽象的单位一个直观的感受，但是现在来看，这个只能用来描述CSS像素，不能用来描述物理像素，而且，即使是描述物理像素，也不那么准确了。所以，在这里，有必要介绍一下CSS中的单位，顺便解释一下这个问题。 CSS的单位分两种：绝对长度单位和相对长度单位。 绝对长度单位 cm：厘米 mm：毫米 in：英寸 pc(picas):一英寸的1/6 pt(points)：一英寸的1/72 px(pixels)：一英寸的1/96 之所以叫绝对长度单位，是因为在只有普通屏幕的时代，相同的单位无论在何种设备上，显示出来的长度都是一致的，并且1cm就是等于物理长度1厘米。而后来，由于Retina显示屏的出现，绝对长度单位里面的“绝对”，是指单位之间关系是绝对固定的。比如，1in = 72pt和1in = 96px是永远固定不变的。关系不变，就需要选取其中一个作为基准： 在打印机设备中，一般是以物理单位作为基准，即1in对应物理单位的1in，此时，1px的长度就是1/96in。所有单位都是与物理长度对应的 而在显示设备（电脑和手机）中，一般是以像素作为基准的。比如在iPhone X中，设备的宽度是2.79in（物理宽度），屏幕分辨率是1125物理像素，window.devicePixelRatio = 3，也就是3个物理像素表示一个CSS像素，所以iPhone X宽度的CSS像素是375px。此时，CSS单位的1in表示的实际长度是2.79 / 375 * 96in = 0.71424in，此时，CSS的1in并不表示物理长度1in 之所以这种绝对长度不再绝对，就是因为多倍屛的出现，使得像素点的物理尺寸缩小。于是，CSS也修改了这些单位的定义，目前已经得到大多数设备的支持。关于这一点，可以参加CSS官方文档：https://www.w3.org/TR/css-values-3/#absolute-lengths 相对长度单位相对于预定义的长度或特征，一般是相对于字体或者viewport，在移动端适配中有很重要的作用 相对于字体 ex (x-height)：等于所用字体的小写字母x的高度 ch (character)：等于所用字体的数字0的宽度 em：相对于最近父级font-size，所以会有层层嵌套的问题，每一层都是相对于最近父级 rem ：相对于html标签的font-size 相对于viewport vh：viewport高度的1/100 vw：viewport宽度的1/100 vmin：viewport宽高较小者的1/100 vmax：viewport宽高较大者的1/100 总结这里花了很大的篇幅去介绍像素，这个看起来简单实际却有点复杂但又必须弄清楚的东西，为后面的移动端适配做基础。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>HTML, CSS, 移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下配置多个Git账户]]></title>
    <url>%2F2018%2F09%2F03%2FMac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAgit%E8%B4%A6%E6%88%B7%2F</url>
    <content type="text"><![CDATA[应用场景我们经常将代码托管到github、gitlab这样的网站上。为了避免每次push代码时都要输入用户名和密码，通常会选择使用ssh协议，将公钥保存到托管网站上。在实际开发中，往往要将代码托管到多个不同的网站上。比如，公司的代码需要托管到coding上，自己的开源代码托管到GitHub上，私有代码托管到gitlab上等等，每个托管网站都对应一个git账户。默认情况下，一台电脑的Git只对应一个账户，只能往一个网站push代码，非常不便。这篇博客将介绍如何在一个Git终端中配置多个账户，同时管理多个托管网站的代码。 准备工作首先，需要准备好对Git的全局用户进行配置。在初次安装Git时，往往会使用如下的命令配置全局用户名和邮箱： 12git config --global user.name "xxx" // 配置全局用户名，如Github上注册的用户名git config --global user.email "yyy@mail.com" // 配置全局邮箱，如Github上配置的邮箱 这个--global选项，是指这里配置的user.name和user.email是相对于全局进行配置的，即不同的Git仓库默认的用户名和邮箱都是这个值。由于需要管理多个账户，所以仅仅使用这个全局值是不够的，需要在每个仓库中单独配置。对此，有两种处理方法： 如果之前已经使用该命令进行配置，则先使用如下命令清除 12git config --global --unset user.namegit config --global --unset user.email 如果不确定是否已经配置过，可以使用下面的命令查看 12git config --global user.namegit config --global user.email 配置步骤1. 对每个账户生成一对密钥首先进入保存秘钥的目录： 1cd ~/.ssh // 进入目录，该目录下保存生成的秘钥 然后，根据账户邮箱生成秘钥。例如我在GitHub上的邮箱是`liugui@hust.edu.cn`，则命令为： 1ssh-keygen -t rsa -C "liugui@hust.edu.cn" 输入完成后，会有如下提示： 12Generating public/private rsa key pair.Enter file in which to save the key (/Users/liugui/.ssh/id_rsa): 这里要求对秘钥进行命名，默认的文件名是id_rsa。为了方便区分，我这里命名为id_rsa_github。接下来的提示都直接进行回车，直到秘钥生成。通过ls命令，可以看到刚刚生成的密钥对id_rsa_github和id_rsa_github.pub。其中id_rsa_github.pub是公钥。 同样，对于GitLab上的账户，我是用另一个邮箱注册的，按照同样的步骤生成id_rsa_gitlab的秘钥对。接下来的步骤，除额外说明外，两个账户的操作完全相同。 2. 私钥添加到本地SSH协议的原理，就是在托管网站上使用公钥，在本地使用私钥，这样本地仓库就可以和远程仓库进行通信。在上一步已经生成了秘钥文件，接下来需要使用秘钥文件，首先是在本地使用秘钥文件： 12ssh-add ~/.ssh/id_rsa_github // 将GitHub私钥添加到本地ssh-add ~/.ssh/id_rsa_gitlab // 将GitLab私钥添加到本地 为了检验本地是否添加成功，可以使用ssh-add -l命令进行查看 3. 对本地秘钥进行配置由于添加了多个密钥文件，所以需要对这多个密钥进行管理。在.ssh目录下新建一个config文件： 1touch config 文件中的内容如下： 12345678910Host github // 网站的别名，随意取HostName github.com // 托管网站的域名User liugui // 托管网站上的用户名IdentityFile ~/.ssh/id_rsa_github // 使用的密钥文件// GitLab的配置相同Host gitlabHostName gitlab.comUser liuguiIdentityFile ~/.ssh/id_rsa_gitlab 4. 公钥添加到托管网站以GitHub为例，先在本地复制公钥。进入.ssh目录，使用vim id_rsa_github.pub查看生成的GitHub公钥，全选进行复制。 登录GitHub，点击右上角头像选择settings，在打开的页面中选择SSH and GPG keys， 在打开的页面的Key输入框中粘贴刚刚复制的公钥，title的名字自己随便去，然后点击下方的Add SSH key按钮： 至此，托管网站的公钥添加完成。总结来说，就是针对每个托管网站分别生成一对密钥，然后分别添加到本地和托管网站。 这时候，可以测试一下配置是否成功，测试命令使用别名。例如，对于GitHub，本来应该使用的测试命令是： 1ssh -T git@github.com 在config文件中，给GitHub网站配置的别名就是github，所以直接使用别名，就是 1ssh -T git@github 如何使用使用有两种情况，一种情况是从远端拉取代码到本地，一种是本地已有仓库需要与远程仓库关联。 1.如果是从远端拉取代码选择SSH协议的复制命令，如对于GitLab上代码库test，其复制命令为 1git clone git@gitlab.com:liugui/test.git 由于使用了别名gitlab，所以实际使用的复制命令应当为： 1git clone git@gitlab:liugui/test.git 这种方法较为简单，修改后的代码无需额外配置，可以直接push 2. 如果是本地已有的仓库这种情况适用于本地新建的仓库需要与远端进行关联，或者之前已经使用sourceTree等图形界面软件拷贝的仓库。进入本地仓库文件夹，需要单独配置该仓库的用户名和邮箱 12git config user.name &quot;liugui&quot;git config user.email &quot;liugui@hust.edu.cn&quot; 然后，进入本地仓库的git目录，打开config文件 12cd .git // 该目录是隐藏的，ls命令不可见，但是可以直接进入，如果是新建的文件夹需要先执行git initvim config 在config文件中，修改（config文件中已有remote “origin”信息）或者添加（config文件中不包含remote “origin”信息）分支信息： 123[remote &quot;origin&quot;] url = git@gitlab:GuiLiu/test.git fetch = +refs/heads/*:refs/remotes/origin/* 主要是URL部分，原生的信息一般是`git@gitlab.com:GuiLiu/test.git`，需要将gitlab.com使用别名gitlab代替。 可以看到，仓库中的关键是要配置好用户名和邮箱，以及使用别名。使用别名的目的是为了通过别名，将本地仓库与密钥目录.ssh文件夹下的密钥进行管理，这样就完成了本地仓库使用的私钥与托管网站使用的公钥的配对，而用户名和邮箱是该仓库使用SSH协议时需要用到的信息 补充一下Coding在关联coding上托管的代码时，遇到了一点麻烦，主要是因为别名的修改不正确，以及20端口禁用的问题导致的，所以单独记录下，.ssh目录下的config文件中的密钥信息应该为： 12345Host codingHostName git-ssh.coding.net // 这个域名使用coding官网获取的，不能写coding.netUser liuguiIdentityFile ~/.ssh/id_rsa_codingPort 443 // 20端口可能被禁用，需要使用443端口]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器优先级]]></title>
    <url>%2F2017%2F05%2F07%2FCSS%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[往往会对同一个HTML标签用到多种样式定义，此时如何确定样式的优先级就很重要，因为这影响到浏览器最终会应用何种样式到这个标签上。用Chrome随意打开一个页面，调出Developer Tools，都可以看到由于CSS选择器优先级导致的样式覆盖，如下图： 在Styles区域，我们可以看到应用在这个div标签上的样式，但是有很多样式被一条横线划掉了，这就表示这个样式被覆盖了。当同一个属性在多个选择器下出现时，就会按照优先级的顺序覆盖。 CSS选择器种类的优先级区分CSS选择器优先级的第一个标准，就是去看这个选择器里面有哪几种选择器，然后根据每一种选择器的优先级作区分，如： 12345678910&lt;style&gt; #hi &#123; color: red; &#125; p &#123; color: blue; &#125;&lt;/style&gt;&lt;p id="hi"&gt;Hello world!&lt;/p&gt; 第一个选择器是ID选择器，第二个选择器是标签选择器，由于ID选择器的优先级更高，所以最终p标签的字体颜色是红色。在CSS中，各种选择器的优先级顺序如下： 使用!important style标签中的样式 具有一个或者多个ID选择器 具有一个或者多个类、属性或伪选择器 标签选择器和伪元素选择器 通配选择器 默认样式 如果选择器里面只有一个选择器，如上面例子的情况，那么就直接按照优先级的顺序判断即可，如果选择器里面有多个选择器，比如下面的例子： 12345678910&lt;style&gt; p #hi &#123; color: red; &#125; .world p &#123; color: blue; &#125;&lt;/style&gt;&lt;p id="hi" class="world"&gt;Hello world!&lt;/p&gt; 此时，第一个选择器下有一个ID选择器和一个标签选择器，第二个选择器下有一个标签选择器和一个类选择器。这种情况下，就要按照下面的规律判断： 先看优先级最高选择器 如果优先级最高选择器相同，那么就看优先级最高选择器的个数 如果个数也相同，那么看优先级次高选择器的种类和个数，以此类推。 在此例中，第一个选择器里面优先级最高的是ID选择器，第二个选择器里面优先级最高的是类选择器，而ID选择器的优先级高于类选择器，所以最终样式是红色。 需要注意的是，这与选择器的顺序无关，如上面的例子中，ID选择器位于第二位，类选择器位于第一位，但是并不影优先级。另外还有一种通过权重的方法来判断优先级，通常权重分配规则是： 带有important的权重为1000； ID选择器的权重为100 类选择器、属性选择器和伪选择器为10 标签选择器、伪元素选择器为1 通配符选择器权重为0 按照这种规则，第一个选择器的权重为100 + 1 = 101，第二个选择器的权重为10 + 1 = 11，所以第一个选择器的优先级更高。 选择器优先级相同时的覆盖规则如果通过上面两种方法计算出来的选择器优先级规则相同，那么就要根据选择器出现的位置决定覆盖规则了，其优先级如下： HTML头部的style标签 style标签中通过@import导入的样式表，如style标签中@import导入的样式表的优先级会高于link标签导入的样式表 通过link元素附加的样式表 通过link元素附加的样式表中@import所导入的样式表 用户最终附加的样式表 如果选择器分组和位置都相同，那么出现在后面的会覆盖前面的。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中数组方法总结]]></title>
    <url>%2F2017%2F05%2F03%2FJavaScript%E4%B8%AD%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[数组是JavaScript中的一种重要引用类型，关于数组的操作方法很多，熟练掌握这些方法对于提升开发效率非常有用，这里做一个总结。需要注意的是，操作字符串时，字符串本身永远不会改变，都是返回一个新的字符串，但是操作数组时情况却不同。所以，总结数组的方法时，我特别标出了那些操作会改变原数组。以下所以操作基于数据： 12var a = ['a', 'b', 'c']; var b = ['d', 'e', 'f']; concat：a.concat(b)：连接数组a和数组b，生成一个新的数组，并且返回新的数组，不改变原数组的值。concat接收的参数可以是数组，也可以是一个或者多个元素 12a.concat(b)//['a','b', 'c', 'd', 'e', 'f']a.concat('c', 'c')// ['a', 'b', 'c', 'c', 'c'] join：将数组中的所有元素连接成一个字符串返回，接收一个可选的参数，表示这些元素之间的分隔符，如果为空则默认用逗号连接，不会改变原数组的值 12a.join()// 'a,b,c'a.jon('') // 'abc' pop：删除数组的最后一个元素并返回，会改变原数组 12a.pop();//ca.length//2 push：向数组的末尾插入一个或多个元素，并且返回新的数组长度，会改变原数组 1a.push('d')//返回4，a = ['a', 'b', 'c', 'd', 'e'] reverse：颠倒数组中的元素顺序，会改变原数组，而不会返回新的数组 1a.reverse()// a = ['c', 'b', 'a'] shift：删除并返回数组的第一个元素，会改变原数组 12a.shift()// 'a'a.length()// 2 unshift：向数组的开头插入一个或多个元素，并且返回数组的长度，会改变原数组 12a.unshift('c', 'd')// ['c', 'd', 'a', 'b', 'c']a.length = 5 slice(a, b):返回数组a出开始到b出结束（不包括）的元素组成的新数组，不会改变原数组 1a.slice(1, 2)// ['b'] splice：删除并添加元素，第一个参数表示开始添加或删除的位置，第二个参数表示删除的个数，这两个参数都是必须的，从第三个参数开始表示插入的元素，返回被删除的元素，会改变原数组 1a.splice(1,1,'a');//返回'b'，数组a变成['a', 'a', 'c'] sort：对数组进行排序，会改变原数组。如果不接受参数，则按照字母表进行排序（注意，此时对于数字也是按照字母表排序，而不是按照大小排序）。可以接受一个函数，函数的两个参数是数组中的两个值，将a和b进行比较，如果a小于b，希望将a小的放在前面，则返回一个负值，否则返回一个正值。一般来说，return a - b是从小到大， b - a是从大到小 every：对数组的每个元素进行检查，不会改变原数组。every中传入一个回调函数，参数是value和index，如果对于每一个value，回调函数都返回true，那么every返回true，只要有一个函数返回false，那么返回false。主要看回调函数的返回值，如果没有返回值，那就是返回false 1a.every(function(value, index)&#123;return value === 'a'&#125;);// false some：对数组的每个元素进行检查，直到找到一个回调函数返回为true的元素，如果找到了，some立即返回true，否则some返回false 1a.some(function(value, index)&#123;return value === 'a'&#125;);// true filter：传入一个过滤函数，对数组的每个元素进行检查，如果使得过滤函数的返回值为true，那么将这些元素作为一个新的数组返回，不会改变原数组 1a.filter(function(value, index)&#123;return value &gt;= 'b'&#125;)//['b', 'c'] forEach：传入一个回调函数，对数组中的每个元素都调用这个回调函数进行处理，回调函数传入三个值，value, index, 和当前的array，同时可以接受第二个参数指定this对象，不会改变原数组 1a.forEach(function(value, index, array)&#123;console.log(value)&#125;)//'a','b', 'c' map：传入一个回调函数，对数组中的每个元素都调用这个回调函数进行处理，并且将回调函数的返回值返回组成一个新的数组返回，回调函数传入三个值，value，index和当前的array，同时可以接受第二个参数指定this对象，不会改变原数组 1a.map(function(value, index, array)&#123;return value + 'b'&#125;)//['ab', 'bb', 'cb'] reduce：对数组中的每个元素执行回调函数，并且回调函数的第一个参数是上一个元素执行回调函数的返回值，除回调函数外，第二个参数是是acc的初始值，不会改变原数组，主要用来对数组值累加处理 12var a = [1,2,3];a.reduce(function(acc,value, index, array)&#123; return acc + value&#125;,0)//6 reduceRight：与reduce相同，但是是从右往左执行，也不会改变原数组 12var a = [1,2,3];a.reduceRight(function(acc, value, index, array)&#123; return acc + value&#125;,0)//6 indexOf：在数组中查找某个元素，并且返回这个元素的index，如果不存在则返回-1.接受两个参数，第一个参数是查找的元素，必选，第二个参数是开始查找的位置，可选 1a.indexOf('a')//0 lastIndexOf：与indexOf相似，但是从后往前查找，返回最后一个元素的index 1a.lastIndexOf('a')// 0 toString：将数组变成字符串返回，其效果与join()不接受参数时相同 valueOf：返回对象的原始值 toLocalString：将数组转换为本地字符串]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中字符串方法总结]]></title>
    <url>%2F2017%2F04%2F06%2FJavaScript%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在JavaScript中，字符串是一种非常重要的数据类型，JavaScript也提供了很多操作字符串的方法，这里做一个总结。需要注意的是：JavaScript中的字符串本身都是不变的，各种操作都是返回一个新的字符串，明确这一点非常重要！ 通常也会把字符串当成一个对象一样处理，所以也有构造函数、实例的概念。下面也是分别从对象的方法和实例的方法两个角度去总结的。但是，字符串本身确实是基本类型。 字符串对象的方法下面的两个对象方法都是操作Unicode码的，在这里先做一个简单的解释。在计算机中，任何数据在本质上都使用0和1存储的，所以就对应多种编码格式，比如ASCII码将8位二进制数与一个ASCII字符对应。而0和1表示的二进制数也可以用十六进制的形式来表示，所以可以认为一个十六进制数也就对应了一个字符。JavaScript中使用了一种称为Unicode的编码，这种编码囊括了世界上各种符号，包括中文符号。简单点理解，还是满足一个十六进制数与一个字符之间的对应关系，而下面这两个方法就是根据十六进制数找出对应的Unicode字符的过程。 String.fromCharCode()：将输入的数字当成Unicode码，转换成相应的char 1String.fromCharCode(55,56,57)//"789" String.fromCharCode不能识别超过32位的Unicode，所以使用String.fromCodePoint，这是ES6中新增的方法。 1String.fromCodePoint(0x20BB7)//"𠮷" String.fromCharCode与charCodeAt方法对应，String.fromCodePoint方法与codePointAt方法对应。这两个方法一般用到较少。 字符串实例的属性字符串本身有一些属性，通过访问这些属性可以获得关于字符串本身的一些信息。 length：获取字符串的长度 constructor：获取字符串的构造函数 prototype：获取原型属性 其中最常用的就是length属性，经常通过访问length属性获取字符串的长度。 字符串实例的方法 设置字符串显示的相关属性，在将字符串插入网页时用到，如使用document.write方法 1234567891011var a = 'hello world';console.log(a.anchor('hah'))//&lt;a name="hah"&gt;hello world&lt;/a&gt;console.log(a.big())//&lt;b&gt;hello world&lt;/b&gt;console.log(a.small())//&lt;small&gt;hello world&lt;/small&gt;console.log(a.bold())//&lt;b&gt;hello world&lt;/b&gt;console.log(a.italics())//&lt;i&gt;hello world&lt;/i&gt;console.log(a.super())//&lt;sup&gt;hello world&lt;/sup&gt;console.log(a.sub())//&lt;sub&gt;hello world&lt;/sub&gt;console.log(a.fontColor('red'))//&lt;font color="red"&gt;hello world&lt;/font&gt;console.log(a.fontSize(7))//&lt;font size="7"&gt;hello world&lt;/font&gt;console.log(a.strike())//&lt;strike&gt;hello world&lt;/strike&gt; 关于char和code的几个方法 1234var a = 'hello';a.charAt(0) // 'h'a.charCodeAt(0) // 104a.codePointAt(0)// ES6中新增的方法，可以返回长度超过2字节的code point es5中indexOf方法：string.indexOf(&#39;a&#39;)，返回字符a在字符串string中的序号，如果没有则返回-1 es5中lastIndexOf方法：string.lastIndexof(&#39;a&#39;)，从后往前搜索，第二个参数指定开始搜索的位置，即从这个位置开始往前搜索 es5中charAt方法：string.charAt(2)，返回指定位置的字符 es5中trim方法：去除字符串两边的空格，对应的还有trimLeft, trimRight方法 es5中的concat方法：连接字符串var a=&#39;hello&#39;;a.concat(&#39;world&#39;); es5中的match方法：接收一个正则表达式，返回的是一个数组，包含匹配的内容。如果正则表达式中包含g，那么是多个匹配元素的数组，否则只有1个。与indexOf相比，这里返回的是value，而indexOf返回的是index es5中的search方法：string.search(regExp)，返回第一个相匹配的index，此方法不考虑g es5中的replace方法：string.replace(regExp/substr, replacement)，返回一个新的字符串，将regExp匹配的部分替换成replacement，RegExp中的g决定了是否是全局替换。同样，在替换时不会改变字符串本身，而是返回一个新的字符串 es5中的slice方法：string.slice(a,b)返回一个新的字符串，从a开始到b，不包含b es5中的substr方法：string.substr(a,b)返回一个新的字符串，从a开始，长度为b es5中的substring方法：与slice用法基本相同，区别是不接受负数 es5中的split方法：将字符串分割为字符数组 字符大小写变化 12345var a = 'string';a.toLocaleUpperCase()// 针对某些特定语言a.toLocaleLowerCase()a.toUpperCase()a.toLowerCase() normalize:将字符的不同表示方法统一为同样的形式 localeCompare方法：将连个字符串进行比较，该比较基于本地区域设置的字符顺序。若小于则返回负数，大于则返回正数，相等返回0var a = &quot;星期一&quot;; var b = &quot;星期二&quot;;a.localeCompare(b)//结果为-1 includes方法：string.includes(&#39;a&#39;)，布尔值，是否包含字符a startsWith方法：string.startWith(&#39;a&#39;)，布尔值，是否以字符a开头。以上两个方法都接收第二个参数，表示开始搜索的位置 endsWith方法：string.endsWith(&#39;a&#39;)，布尔值，是否以字符a结尾。接收第二个参数，表示搜索的范围为前n个字符 repeat方法：string.repeat(n)，返回一个字符串，将源字符串重复n次 padStart方法：string.padStart(n, &#39;abc&#39;)，返回一个字符串，长度为n，开头的部分以’abc’循环的方式补齐，直到截断，如果没有第二个参数，则默认用空格补齐 padEnd方法：string.padEnd(10, &#39;abc&#39;)，返回一个字符串，长度为n，结尾的部分已’abc’循环的方式补齐，直到阶段，如果没有第二个参数，则默认用空格补齐。补齐时，不够则重复，超过则截断，所以也是一种拼接字符串的方法 raw方法：用于模板字符串，替换所有变量，而且对斜杠进行转义，方便下一步作为更原始的字符串形式来使用]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的typeof,instanceof,isPrototypeOf用法总结]]></title>
    <url>%2F2017%2F03%2F15%2FJavaScript%E4%B8%AD%E7%9A%84typeof%2Cinstanceof%2CisPrototypeOf%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在JavaScript中，经常用到typeof, instanceof和isPrototypeOf方法来判断类型或者对象之间的关系。typeof和instanceof都是操作符，并不是函数。也就是说，在调用的时候，并不是像函数调用那样加上括号，而是直接当成一个操作符，如typeof a来判断变量a的类型，而不是通过typeof(a)的方式来调用。而isPrototypeOf就是一个方法，调用时需要加括号。我是从字母大小写来区分的：typeof和instanceof都是全小写的，所以是操作符；而isPrototypeOf是驼峰式的，所以是函数。 首先强调一下类型：在JavaScript中，一共有5中基本类型：Null, Undefined, String, Boolean, Number。另一种是引用类型，主要是对象，对象往下又分为Array，Date， RegExp和Function等。 typeoftypeof运算符用来判断类型，返回的结果都是字符串形式的小写字母。 typeof undefined: “undefined” typeof null: “object” typeof true: “boolean” typeof “abc”: “string” typeof 123: “number” typeof [1,2,3]: “object” typeof Object: “object” typeof function: “function” typeof Date: “object” typeof /12/: “object” 也就是说，对于基本类型，typeof可以基本很好的进行判断，需要注意的是对于null返回值是”object”，这是因为null可以理解为是一个空指针，而指针引用的是对象。其他的基本类型都返回对应的类型值。 而对于object类型，只有对于函数返回”function”，其他的引用类型全部返回”object”。也就是说，对于对象类型的判断，typeof是很弱的，所以就需要用到instanceof和isPrototypeOf了 instanceofinstanceOf方法用来检测一个对象是否是某个构造函数的实例。基本用法如下： 123456789101112131415/* 判断Array */var a = [1,2];// 定义a是一个数组a instanceof Array;// true/* 判断RegExp */var a = /123/g;// 定义a是一个RegExpa instanceof RegExp; // true/* 判断Date */var a = new Date();// 定义a是一个Datea instanceof Date; // true/* 判断function */var a = function() &#123;&#125;;// 定义a是一个Functiona instanceof Function;// true 与typeof不同的是，instanceof可以很方便的判断出一个对象是不是某种内置对象类型的实例。拿数组来说，声明一个数组其实相当于调用了Array的构造函数，如： 12var a = [1,2];var a = new Array(1,2); 这两种声明数组的方式是等价的，所以instanceof运算符就能判断出a是Array的实例。这是对于内置的引用类型，对于自定义的构造函数，同样满足这个规律： 12345function Person() &#123; this.age = 22;&#125;var p = new Person();p instanceof Person;// true 这里面声明了一个Person作为构造函数，并且调用Person函数创建一个p实例，然后再通过instanceof方法判断p与Person的关系。如果考虑继承，同样也是满足的，只要是在实例的原型链中出现的构造函数，都会返回true，如： 1234567891011121314function Person() &#123; this.age = 22;&#125;function Teacher() &#123; this.type = 'teacher';&#125;Teacher.prototype = new Person();var t = new Teacher();t instanceof Teacher;// truet instanceof Person;// truet instanceof Object;// true 这里创建了一个名为Teacher的构造函数，并且将其原型指向名为Person的构造函数创建的实例，也就是说Person位于Teacher的原型链上。调用instanceof时，t既是Teacher的实例，也是Person的实例，同时所有对象都来自Object，也就是Object的实例。 isPrototypeOfisPrototypeOf判断实例和原型对象之间的关系，如： 1234567891011121314function Person() &#123; this.age = 22;&#125;function Teacher() &#123; this.type = 'teacher';&#125;var p = new Person();Teacher.prototype = p;var t = new Teacher();p.isPrototypeOf(t);// trueObject.prototype.isPrototypeOf(p);// true 在这里，p是构造函数Teacher的prototype，也就是实例t的prototype。只要是原型链上出现的prototype，都返回true。所以，Object的prototype也返回true。只要弄清楚原型链的继承关系，isPrototype和instanceof就很容易弄清楚了！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的类型转换]]></title>
    <url>%2F2017%2F03%2F07%2FJavaScript%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[JavaScript中的变量分为基本类型和引用类型，基本类型有5种，分别是null, undefined, 字符串，数字，布尔型。这里分析JavaScript中基本类型之间的转换。 1. null与undefinedundefined类型的值只有一个undefined，null类型的值只有一个null，注意都是不加引号的，如果加了引号就是字符串了。如果一个变量声明之后没有赋值，那么这个变量就是undefined。一般不会将一个变量的值赋值为undefined，但是可以显示的将一个变量的值赋值为null。需要注意的是： 12null == undefined// truenull === undefined // false 2. 转换成Boolean类型Boolean类型只有两个值：true和false。JavaScript是区分大小写的，所以True并不是Boolean类型。 转换成Boolean的方法 调用Boolean函数，如Boolean(123)会将数字123转换成true 在判断语句中，如var a = 123; if(a){}，在JavaScript中经常这样使用，虽然没有显式调用，但是其实已经隐式的调用了Boolean(a)，相当于if(Boolean(a)){} 巧妙的使用!!，如var a = 123; var b = !!a 转换成Boolean的规则 对于字符串：任何非空字符串转换为true，空字符串转换为false 对于数字：任何非零数字转换为true，0和NaN转换为false 对于对象：任何对象转换为true，即使是空对象也会转换为true 对于null：null会被转换为false 对于undefined：会被转换为false 总结来说，转换为false的只有5种值：null, undefined, 空字符串，0和NaN 3. 转换为Number类型数字类型表示JavaScript中的所有数值类型，如123就是一个数字类型。 转换成Number的方法 使用Number()函数转换成数字 使用parseInt()将字符串转换成整型数字 使用parseFloat()将字符串转换成浮点数 巧妙的是使用+转换成数字类型 123var a = '22';+a;// 22+true// 1 转换成Number的规则 对于字符串：纯数字类型的字符串转换为数字，如Number(&quot;123&quot;)结果为123。如果字符串中包含非数字字符，则转换为NaN，如Number(&quot;12LL&quot;)结果为NaN，一种特殊情况是使用parseInt或者parseFloat对于16进制数转换时，如： 12parseInt('1A');// 不带基数，默认为10，结果为NaNparseInt('1A', 16);// 基数为16，表示是十六进制数，结果为26 对于Boolean：true转换为1，false转换为0 对于对象：先调用对象的valueOf方法，如果是NaN，再调用toString方法 对于null：null被转换为0 对于undefined：undefined被转换为NaN 4. 转换为String字符串类型一般有双引号或者单引号，如&quot;123&quot;和&#39;123&#39;都是字符串。 转换为String的方法 toString()方法：除了null和undefined之外，都有这个方法，可以接受一个参数表示输出的基数。Object.toString()返回’[object Object]’,function.toString()返回函数的字符串，数组返回数组元素的字符串 用String()方法：如果里面的值有toString则调用toString，null返回’null’, undefined返回’undefined’ 直接用加号连接一个空字符串转换字符串 123var a = '12';var b = 34;var c = a + b;//'1234' 转换成String的规则 对于数字：直接转换为字符串 对于Boolean：true转换为&#39;true&#39;，false转换为&#39;false&#39; 对于对象：调用对象的toString方法 对于null：转换为&#39;null&#39; 对于undefined：转换为&#39;undefined&#39; 5. toString与valueOf除了null和undefined之外，每种数据类型都有这两个方法。toString()方法一般是转换成字符串形式，valueOf一般是返回源对象。一般来说，需要转成数字时，如比较大小，调用valueOf方法，需要转成字符串时，如console.log，调用toString()方法。 对于数字：valueOf返回本身，toString转换为字符换 对于Boolean：valueOf返回true， toString返回&#39;true&#39; 对于字符串：都返回字符串本身 Object对象：toString返回’[object Object]’，valueOf返回源对象 Array：toString返回split()相同的返回，valueOf返回原数组 Date：toString返回包含时区的字符串，valueOf返回毫秒数 RegExp：toString返回字面量，valueOf返回源对象 Function：toString返回函数代码字符串，返回函数代码 总结这里列出的是基本类型之间的转换规则，实际应用中，类型转换很可能隐式的发生，如执行console.log(a)函数时，会将a转换成字符串类型，再打印出来。只要记住这些转换规则，在需要转换的地方应用这些转换规则即可。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenSeadragon绘图逻辑解析]]></title>
    <url>%2F2016%2F08%2F26%2FOpenSeadragon%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BupdateViewport%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[我们的项目中用到了OpenSeadragon库，OpenSeadragon是一个强大的库，主要功能是实现在Web端迅速的浏览大图，并且可以流畅的进行缩放、滑动等，用户体验非常好！关于OpenSeadragon，网上能找到的资料非常少，中文资料就更少之又少了。我花了很长时间去认真研究了OpenSeadragon的源码，尤其是OpenSeadragon的绘图部分，这篇博客就介绍了OpenSeadragon里面最核心的绘图逻辑，博客内容百分百原创，转载请注明出处！ 几个概念 当前显示图片大小：在每次执行updateViewport时，zoomSpring, centerSpringX和centerSpringY都会执行update,更新到当前动画帧时刻的状态值（也可以理解成当前动画帧完成时），也就是spring.current.value值，在此时图片的实际大小，以px为单位。当然如果是初始打开时，这个值可能不会改变。 目标图片大小：所有动画完成后（而不是当前帧完成后）的最终状态时图片的实际大小，以px为单位，其实就是spring.target.value状态时的图片大小。 两层遍历：第一次遍历：level级遍历，对于highestLevel和lowestLevel范围内的每一个level进行一次遍历。第二次遍历：tile级遍历，对于每个level中，需要用到的所有tile进行一次遍历 重要参数针对循环的全局变量 lowestLevel: 数字值，渲染当前状态所需要的最低dzi等级。根据用户配置的minZoomImageRatio计算，minZoomImageRatio的意义是表示缩放到最小时，图片的大小与viewport大小的比值（也就是宽或者高的比值），默认值为0.9。计算方法：1234567lowestLevel = Math.max( drawer.source.minLevel,//dzi的最低level Math.floor( Math.log( drawer.minZoomImageRatio ) / Math.log( 2 ) ) ) 一般来说，lowestLevel的值都为0，只有当minZoomImageRatio的值大于2时，lowsetLevel的值才会超过1，而一般情况下minZoomImageRatio的值都不会超过2。 highestLevel: 数字值，渲染当前状态所需要的最高dzi等级，根据用户配置的minPixelRatio计算，minPixelRatio的值越小，那么用户最后看到的效果越清晰，默认值为0.5。计算方法：1234567highestLevel = Math.min( Math.abs(drawer.source.maxLevel),//dzi的最高level Math.abs(Math.floor( Math.log( zeroRatioC / drawer.minPixelRatio ) / Math.log( 2 ) )) ), 这里的zeroRatioC是当前显示图片宽度与level 0图片宽度的比值。minPixelRatio的实际意义是当前显示的图片宽度与某个level图片宽度的比值，Math.min的第二个表达式就是讲这个level的数值计算出来，这个level就是highestLevel。所以，minPixelRatio的值越小，highestLevel的值越大，用户看到的效果就越清晰，但这个highestLevel不会超过dzi所提供的maxLevel。 lastDraw: 一个数组，是这次循环完成后，需要画到画布上的tile构成的数组。这个数组是个全局属性值，对于当前循环开始时来说，里面存储的是上次循环结束后的tile信息，所以命名为lastDrawn。在updateViewport函数的一开始，应该将这个数组清空，以便存入这次遍历的结果。存入时，是按照从高到低的顺序将下载好的并且未被覆盖的tile放到这个数组中。在后面的drawTiles函数中，是从后向前遍历画出，即先画出低清晰度版本，再画出高清晰度版本，高清晰度版本会覆盖低清晰度版本的一部分，所以会出现部分清晰部分模糊的现象。lastDrawn数组中，按照level从高到低，最低level的tile情况必须是完整的，即是这个level的所有tile，高层次的level中是更高分辨率的部分tile。当这个最低的完整level是highestLevel时就完成了遍历。注意放到下载队列的顺序和放到lastDrawn的顺序策略不同。放到下载队列时，是根据tile的优先级顺序，一般是从低分辨率版本到高分辨率版本，每次updateViewport只找到一个best。而放到lastDrawn的顺序是从高分辨率到低分辨率，每次updateViewport都会对lastDrawn数组中的内容重新排放。一次updateViewport寻找一个best的方法主要在两个方面：一是看这个tile是否被cover，如果是就不用比较了，否则就与其他比较。当然，在Level遍历层面，tile的cover情况上升到对这个level的cover情况的判断，这样这个level中的所有提了都不用考虑了。总体来说，寻找best的顺序是：按照从closetLevel到highestLevel、从中间到两遍的优先级顺序，从低分辨率到高分辨率版本，考虑每一个tile，如果某个tile被cover，则跳过这个tile，如果一个level中的所有tile被cover，则跳过这个level。 haveDrawn：布尔值，默认为false。haveDrawn针对每次updateViewport只有一个，所以如果在某次遍历中改变了haveDrawn的值，以后的遍历都会受到影响。其作用是精确当前update动画帧需要画出的level范围。从高向低搜索时，只要有一个高的level满足了minPixelRatio的需求，那么下面的level必然是满足的，就不需要再继续检查了。需要这样做的原因，是由于在求取highestLevel时用了一个Math.abs，在minPixelRatio给的很大或者当前显示图片很小的极端情况下，求取的highestLevel本身可能是个负值变来的绝对值，这种情况下就不能满足大于等于minPixelRatio的需求，就要继续往下面的level的搜索，而搜索的极限是lowestLevel，这时即使是不满足的，也要强制使用了。这属于对极端情况的处理。haveDrawn为true时，表示这次updateViewport是有绘画工作要执行的，因为存在满足条件的level。由于是从高向低遍历，在求得使haveDrawn为true的level时，会同时将这个level的drawLevel值设为true，lowestLevel的值也为true，其他level的drawLevel值都为false。drawLevel的作用是为了后面的coverages三维数组的设定。 tileMatrix：三维数组：[level][x][y]到tile的映射。这里面存储着每个tile的信息，除了包含level,x,y这些基本信息以外，还包括：bounds: 这个tile在图片坐标系中相对于图片的归一化信息，包括左上角顶点的坐标以及tile的相对宽高exists: 布尔值，标识这个tile是否存在，即是否超出这个图层的tile范围，一般都为trueurl： 这个tile的URL，可以据此下载tile coverage: 三维数组：[level][x][y]到布尔值的映射。记录对应tile的cover值，为true时表明这个tile已经被cover，意思是这个tile本身已经下载完成，或者被更高的tile代替。被cover的意义是表示这个tile本身已经下载完，或者被更高级别的tile覆盖。在level级遍历中，如果整个level被cover，则不需要再对这个level以下的level遍历；在tile级遍历中，可以通过多次调用这个函数判断这个tile是否被更高级别的tile所覆盖。coverage数组的构成：对于只有highestLevel（或者满足minPixelRatio的最低level）和lowsetLevel，对应的cover值都是undefined，对于其他的level，如果某个tile不需要下载，那么是undefined，如果需要下载且未下载完，那么是false，如果是需要下载且已经下载完则为true，其他的都是undefined。即coverage数组的true和false只针对临界level以外且需要考虑绘画的tile。 针对循环开始后每次循环中每个level的变量 renderPixelRatioC: 数字值，当前显示的图片宽度与该level图片宽度的比值这个值是随着level的增大而减小的，从高的level向低的level遍历时，这个值会越来越大 renderPixelRatioT: 数字值，目标图片宽度与该level图片宽度的比值这个值是随着level的增大而减小的，从高的level向低的level遍历时，这个值会越来越大 drawLevel: 布尔值，默认为false。只有highestLevel（或者满足minPixelRatio的最低level）和lowsetLevel为true，其他level对应的值均为false。drawLevel对应后面tile级循环中的drawTile，当其值为true时，表示这个tile是要被画出来的，为false时表示这个tile已经被覆盖，不需要再画出来。在后面的updateTile函数中，对drawTile（即drawlevel针对每个tile的具体值）的值会重新判断，标识这个tile是否要画出。可以看到，highestLevel（或者满足minPixelRatio的最低level）和lowsetLevel每次遍历时(只要lowestLevel不是被直接cover判断跳过)都要考虑到必绘画，即在lowestLevel被cover之前，每次绘画都会将其放在lastDrawn数组中，这也是为了确保每个区域最起码都有图显示，虽然分辨率可能不同。 getClosetLevel(): 一个函数，执行的结果是获取最接近的level值。这个最接近的原意是指某个level的图片与viewport的窗口大小最接近（但不超过），而实际计算的结果，确是将这个level向下降了2层，即减去2。 zeroRatioT： 数字值，目标图片的宽度与最接近level图片宽度的比值 optimalRatio: 数字值，最佳的pixelRatio值。有一个用户配置的immediateRender布尔值，默认为false，但是如果用户设置为true，那么optimalRatio的值为1，否则，optimalRatio的值等于zeroRatioT。 levelOpacity： 衡量整个level透明度，数字值。level越高，levelOpacity越小。 levelVisibility： 数字值，衡量这个level的优先程度。levelVisibility是衡量这个level中tile下载顺序的重要因素,tile排序时，levelVisibility越大越好。计算方法如下; 123levelVisibility = optimalRatio / Math.abs( optimalRatio - renderPixelRatioT); 如果用户配置的immediateRender为false，即默认情况下，那么closetLevel的levelVisibility为无穷大，肯定排在下载队列的最前面，然后level越高，其levelVisibility越大。如果用户配置immediateRender为true，那么当前level的图片宽度与目标图片宽度越接近时，levelVisibility的值越小。levelVisibility随level的关系是非线性的，增减速度上来说，level越高时，其levelVisibility越大。 best: 本次update找到的最佳的tile，默认为false 两层遍历的过程level级遍历 首先计算出viewport在这个level中显示时，对应的tile范围。并且获取这个level所有的tile数目，以及其对应的水平方向和垂直方向的分布情况； 将这个level对应的coverage数组清空。coverage数组是标识这个level中的每个tile是否被更高级别的tile覆盖的情况，是一个三维数组，存储的是布尔值； 在这个level上与viewport显示所需要用到的tile，也就是第一步获取的tile范围之中，进行tile级遍历。 对一个level遍历完成后，要检查该level中所有需要的tile的coverage是否为true，如果是，那么表明合格level中所有需要的tile已经下载完成，或者已经被更高的level覆盖。这时跳出循环，对lastDrawn数组中的所有tile执行绘画操作。由于遍历时从高到底的，所以画出的总是最高level的。 tile级遍历 从tileMatrix中获取这个tile的信息，如果没有，则将信息存储到tileMatrix中； 默认将coverage数组里面对应的值设置成false； 如果这个tile.exists属性为false，即不存在，那么则返回之前的best为best tile； 对于除最高level（指highestLevel或者满足minPixelRatio的最大level）和lowestLevel（因为只有这两个level的drawLevel为true）之外的level中tile，要判断它是否已经被更高level中对应的tile覆盖，也就是在coverage数组中的对应值是否为true。如果已经被覆盖，那么设置该tile的coverage对应值为true，并且返回之前的best为best tile，表明这个tile已经没必要再继续显示出来，避免了后面不必要的操作。否则，继续执行后续操作。 给此tile进行定位。定位的结果返回以下信息： position：该tile左上角相对于viewport左上角顶点的真实坐标 size：该tile在当前动画帧显示状态下，对应的大小。也就是当前画到画布上时对应的大小 distance：动画终态时,该tile中心与viewport中心点的距离 visibility：该tile的优先级参数，也就是前面level中计算的levelVisibility 检查该tile的下载状态，有两个属性：tile.loading表示该tile是否正在下载，tile.loaded表示该tile是否已经下载完成，都是布尔值。这两个值都是由下载队列控制的。 如果已经下载完成：那么表明这个tile是之前遍历中已经找到的best tile，所以此次循环直接返回上一次的best为best tile。然后将之前的best tile加入到lastDrawn数组中，在两次遍历结束后就可以开始绘画；同时，要将该best tile对应的cover值设置为true，这样，它下面的level对应的tile就不需要重复。 如果正在下载中，那么表明这个tile是之前遍历中已经找到的best tile，所以此次循环直接返回上一次的best为best tile。总结：返回之前的best（如果是第一轮，那么之前的best就是null）作为本次循环的best tile情况总结起来有以下三种：这个tile已经被cover，这个tile已经被下载或者这个tile正在下载中 如果tile.loading和tile.loaded都为false，那么表明这个tile还没有加入下载队列，即不是之前循环中找到的best。那么，将这个tile和之前的tile进行一次比较。比较时先比较levelVisibility，然后比较tile.distance，在当前的tile和之前的best tile中，返回levelVisibility较大的一个，如果两者相等，那么返回tile.distance较小的一个，如果都相等，那么返回之前的best tile即可。 总结两级遍历分别完成的功能 level级遍历：找出该level下对应当前显示状态时，需要用到的tile范围，然后对这些tile进行遍历 tile级遍历：在level级遍历确定的tile范围中，对每个tile执行相应操作，主要有：如果能找到新的best，那么返回这个tile作为新的best，其中包含了这个tile的定位信息。在遍历时，对于之前所有updata找到的，已经加入下载队列下载完成的所有tile，并且在level级遍历中确定范围时也是取得这些tile对于当前显示也是需要的，则重新根据当前动画帧的状态对其定位，然后加入lastDrawn数组中，在遍历完成后绘出。 updateViewport过程总览 进入后，首先计算前文提到的一些常量，并且清空数组和画布，为后面的绘画做准备。 对所有的level中的tile遍历。遍历的过程中会对用到的所有已经下载的tile重新对当前动画帧定位。遍历完成后，将lastDrawn数组里面的tile画出。此时对应的lastDrawn有两种情况：一是某个level中的全部tile已经cover，即从providesCoverage判断跳出来的，直接画出更高清晰度的版本；这种情况主要对于移动，当然移动时也有可能下载。二是lastDrawn中包含了不同level的已经下载好的tile，此时的tile不会出现覆盖的情况，所以此时绘出时可能是同一张图片上不同位置的清晰度不同。同时，将这次update找到的best（如果有）加入下载队列。这种情况可以简单理解为初次打开或者缩放时，当然拖动时也会有。 updateViewport流程图]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript openSeadragon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重装系统后hexo写博客功能的恢复]]></title>
    <url>%2F2016%2F04%2F30%2F%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8Ehexo%E5%86%99%E5%8D%9A%E5%AE%A2%E5%8A%9F%E8%83%BD%E7%9A%84%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[前两天重新给电脑装了个win10，之前存放在C盘的里面的hexo全部没有了，折腾了半天，终于恢复了hexo写博客的功能，现在记录下来，给需要的朋友备用。 对于hexo来说，两个配置文件是最重要的，一个是hexo本身的配置文件，位于”你的hexo主目录/“下的”_config.yml”，另一个是主题的配置文件，位于”你的hexo主目录/themes/你的主题文件夹/_config.yml”，这两个文件一定要记得备份，如果没有了，那就只能重新配置了。另外就是source文件夹下的博客文章资源等，也应该做好备份。如果没有备份，那么恢复hexo的发博客功能也是没有关系的，但是配置上和博客文档上可能需要自己重新配置了。 首先声明，以下所有的操作都假定你之前的hexo已经配置好，博客系统可以正常工作，只是因为重装系统或者其他操作失去了本地的hexo文件夹，现在要恢复hexo而已，并且以下都是基于windows系统的。 安装git和nodejs这两个软件是hexo可以正常工作的基础，必须要先安装好。安装后，要在cmd命令行执行node -v和npm -v检查是否安装成功。 安装hexo如果git和npm都已经安装好了，那么现在可以直接安装hexo了，在命令行中执行以下命令： npm install -g hexo-cli 将hexo安装到全局。 建立hexo文件夹在自己选定的某个目录下，新建一个文件夹，这个文件夹就是之前的hexo文件夹，可以命名为’hexo’。进入hexo文件夹，按住shift加鼠标右键，选择“在此处打开命令窗口”（或者直接通过cmd进入此文件夹也可），在打开的命令行窗口中执行： hexo init 此命令执行完成后，会在该文件夹下生成多个文件，这是hexo的基本文件，然后继续执行： npm install 安装hexo必须的依赖包。安装时可能会有一些warning的提示，但一般不会影响使用。可以进入node_modules文件夹查看安装的依赖包情况。至此hexo文件夹的基础部分就恢复了。 如果备份了hexo的配置文件_config.yml，可以直接将文件复制过来覆盖，如果没有备份，那么就只能自己重新配置了。 恢复主题先在网上搜索自己需要恢复的主题的github链接，进入hexo/themes文件夹，鼠标右键，选择”Git Bash Here”，打开git窗口，执行 git clone http://你找到的gitbub链接 克隆完成后，进入该主题的文件夹。如果之前备份了主题的_config.yml文件，则直接复制过来覆盖。hexo的_config.yml文件和主题的_config.yml不是同一个文件，前面已经提过。如果没有备份，那么只能重新配置一遍。 测试本地至此，本地的配置已经完成了，可以先进行简单的本地测试。进入hexo文件夹，打开命令行窗口，或着打开Git的命令行窗口也可，执行： hexo g 此时可以看到hexo在执行生成页面文件，再执行 hexo s hexo启动本地服务，浏览器中输入’http://localhost:4000/&#39;，可以看到在本地的预览效果。至此，说明本地的配置已经完成。 恢复与github的链接恢复到github有以下几个步骤： 配置_config.yml中的deploy在hexo根目录下的_config.yml文件中，要配置deploy（如果是之前已经备份的则不需要改变，如果是重新写那么先要配置这个选项），格式为： deploy: type: git repository: git@github.com:yourname/yourname.github.io.git branch: master 配置公钥一般来说，重装系统后并没有配置SSH Keys，所以还要配置SSH Key。在hexo文件夹中点击鼠标右键选择“Git Bash Here”打开命令行窗口，执行以下命令： $ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot; 此时会看到窗口显示以下信息 Generating public/private rsa key pair. Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa): 要求用户选择公钥的存放路径，可以手动定制，也可以直接回车放在默认的路径，后面要用到这个路径。然后，系统会要求用户输入密码： Enter passphrase (empty for no passphrase):&lt;输入加密串，回车&gt; Enter same passphrase again:&lt;再次输入加密串，回车&gt; 此时命令行窗口会显示以下内容： 说明公钥已经生成。 添加公钥到Github：找到刚刚生成的公钥文件，文件名为id_rsa.pub。如果是自定义的公钥存放路径那是在该目录下，否则是默认的路径下。在我的win10系统中，默认路径是在’C:\Users\cattle.ssh’目录下，cattle是我的windows用户名，如果在win7系统，应该在’C:\Documents and Settings\Administrator.ssh\’，如果实在找不到，在上面公钥生成后的提示中也可以找到，如上面的截图中的第一句就是路径信息，如果你把窗口关了，好吧，按照文件名搜一下吧。找到这个文件，用文本编辑器打开。 登录到Github，点击头像，在下拉菜单中选择Account Settings–&gt;SSH Public keys –&gt; add another public keys，会弹出一个文本框，title随意填写，然后复制文本编辑器中的内容，直接复制粘贴到Key中，点击Add key按钮即可。 设置用户信息用户信息被Github用来记录提交信息。执行以下命令： $ git config --global user.name &quot;cnfeat&quot;//用户名 $ git config --global user.email &quot;cnfeat@gmail.com&quot;//邮箱 至此，已经完成了到Github的连接。 添加CNAME和README文件此时，如果直接执行hexo g和hexo d，按照提示输入密码，就可以部署了。但是在浏览器中输入域名打开时会提示404，原因是缺少CNAME文件。 在hexo/source文件夹下，新建一个文本文件，里面的内容是域名，如’liugui.me’，然后保存，关闭，选中点击右键，属性，将文件名改成CNAME，去掉后缀，弹出的提示框直接选是。 另外，一般还需要一个README文件，同样是新建文本，内容自己写，是描述自己的博客的，然后修改属性，去掉后缀。注意，千万不要把后缀改成md，这样会编译成一个HTML文件。 重新执行以下命令： hexo g hexo d 然后，在浏览器中可以打开了。 小结至此，已经完成了全部操作。提醒大家平时要备份配置文件，这样以后恢复的时候就方便多了。]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习WebGL(三)：创建基本的WebGL程序]]></title>
    <url>%2F2016%2F03%2F26%2F%E5%AD%A6%E4%B9%A0WebGL-%E4%B8%89-%EF%BC%9A%E5%88%9B%E5%BB%BA%E5%9F%BA%E6%9C%ACWebGL%E7%9A%84%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[前面两篇博客介绍的是关于WebGL的一些预备知识，但都没有涉及到代码。这篇博客介绍一个基本的WebGL程序，这个程序的最终效果是在屏幕上绘制一个白色的三角形。程序虽然简单，但是可以从这个小程序来分析WebGL程序的基本结构，以及编写WebGL应用程序的基本流程。 WebGL程序的基本结构WebGL程序的基本结构如下所示。为了看出整体结构，我省去了每个函数的具体代码实现，这些代码实现将在后面逐步介绍。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE HTML&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;title&gt;First WebGL Application&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script id="shader-vs" type="x-shader/x-vertex"&gt; // 顶点着色器的源码 &lt;/script&gt; &lt;script id="shader-fs" type="x-shader/x-fragment"&gt; //片段着色器的源码 &lt;/script&gt; &lt;script type="text/javascript"&gt; // 定义一些全局变量 var gl, canvas, shaderProgram, vertexBuffer; function createGLContext(canvas) &#123; // 创建WebGL环境 &#125; function loadShaderFromDOM(id) &#123; // 创建Shader，引入源码，并且编译链接 &#125; function setupShaders() &#123; // 创建Program，链接Shader &#125; function setupBuffers() &#123; //设置WebGL缓存对象 &#125; function draw() &#123; // 绘画的主函数 &#125; // startup函数，负责整个流程 function startup() &#123; canvas = document.getElementById("myGLCanvas"); gl = WebGLDebugUtils.makeDebugContext(createGLContext(canvas)); setupShaders(); setupBuffers(); gl.clearColor(0.0, 0.0, 0.0, 1.0);// 定义初始化画布的颜色，即背景色 draw(); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body onload="startup();"&gt; &lt;canvas id="myGLCanvas" width="500" height="500"&gt;&lt;/canvas&gt;&lt;/body&gt;&lt;/html&gt; startup()函数是程序的主函数，当页面加载完成后触发，通过它来调用各个函数，控制整体的绘画流程。下面逐步介绍。 创建WebGL环境要使用WebGL提供的API，首先要创建WebGL环境，获取WebGLRenderingContext对象。所以，在HTML代码部分，需要有一个&lt;canvas&gt;标签。用document.getElementById找到这个DOM对象后，调用getContext方法获取WebGLRenderingContext对象，然后将该对象保存在全局变量gl中，之后就可以通过gl来调用WebGL的API，以及访问WebGL的内置变量了。 12345678910111213141516171819function createGLContext(canvas) &#123; var names = ["webgl", "experimental-webgl"]， context = null; for (var i = 0; i &lt; names.length; i++) &#123; try &#123; context = canvas.getContext(names[i]); &#125; catch (e) &#123;&#125; if (context) &#123; break; &#125; &#125; if (context) &#123; // 设置WebGL会话窗口的大小与Canvas画布的大小一致 context.viewportWidth = canvas.width; context.viewportHeight = canvas.height; &#125; else &#123; alert("Failed to create WebGL context!"); &#125; return context;&#125; 在WebGL标准定稿前，使用getContext()函数输入的参数是”experimental-webgl”，在WebGL标准正式定稿之后，变成了”webgl”，为了考虑新旧浏览器的兼容性，最好将这两个参数都写出来。这里使用一个try-catch语句，只要有一个输入参数获取WebGLRenderingContext对象成功了，就使用break语句跳出。获取环境对象后，访问环境对象的viewportWidth和viewportHeight属性，这两个属性分别表示WebGL最终绘画的视口（viewport）的宽度和高度。视口就是最终在画布上绘画的区域。如果设置的宽高比与canvas的宽高比不同，则显示的时候看起来会扭曲，如果设置的大小超过了画布的大小，那么会有一部分在画布之外而无法显示。我们将视口宽高设成与canvas画布的宽高一致。最后，将这个WebGLRenderingContext对象返回给调用函数。 编写Shader源码为了方便，将Shader的源码写在单独的&lt;script&gt;&lt;/script&gt;标签里面。也有另一种方法，是将shader源码以字符串形式直接写在JavaScript代码中。使用第一种方法的好处是，可以将Shader代码和JavaScript代码分开，而且避免了使用字符串编写时要用到的很多’+’号连接，提升易读性，这一点在Shader源码变得复杂时尤为明显。 123456789101112&lt;script id="shader-vs" type="x-shader/x-vertex"&gt;// 顶点着色器(vertex shader)的源码 attribute vec3 aVertexPosition; void main() &#123; gl_Position = vec4(aVertexPosition, 1.0); &#125;&lt;/script&gt;&lt;script id="shader-fs" type="x-shader/x-fragment"&gt;// 片段着色器(fragment shader)的源码 precision mediump float; void main() &#123; gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0); &#125;&lt;/script&gt; &lt;script&gt;标签里面本来是用来存放JavaScript代码的，一般type值为”text/javascript”，这也是type的默认值，它告诉浏览器这里面存储的是JavaScript代码，浏览器便会执行。当type设置成了其他值时，浏览器就不会执行&lt;script&gt;标签里面的代码。所以，我们就可以将用GLSL ES编写的Shader的源码放在&lt;script&gt;标签中。WebGL中的两种着色器都有自己的结构特点、输入和输出值，分别比较如下： 顶点着色器顶点着色器的输入包括： vertex shader的实际源代码： 用GLSL ES设计的。因为是可编程的，所以可以输入代码 attribute变量： 用户自定义的变量，包含特定于每个顶点的数据 uniform变量： 用户自定义的变量，用来表示所有顶点都相同的数据，在一次绘制调用期间保持不变 顶点着色器的输出包括： 内置特殊变量： 以gl_开头，如gl_Position,gl_FrontFacing varying变量： 从vertex shader发送到fragment shader 在本例的vertex shader源码中，输入只有一个attribute变量aVertextPostion，表示输入的顶点数据，vec3表示它的数据是一个三维向量，即一个顶点的三个坐标。类似的，vec4表示四维向量，mat4表示四维矩阵，mat3表示三维矩阵。这些是GLSL ES语言中规定的数据类型。前面介绍WebGL数据时提到，向量和矩阵是WebGL中经常用到的数据类型。 vec3是变量的数据类型，而attribute和uniform是变量存储限定符。attribute类型的变量是普通的变量，在Shader中可以修改attribute变量的值，Shader执行时，它的值针对每个顶点可以是不同的。而uniform变量在Shader中是不可以修改的，只能读取，在一次绘制调用期间它对每个顶点的值都是相同的。 varying表示定义一个可变变量，即这个变量的值是可以改变的，主要用来做颜色的自动插值计算。比如，要绘制一条线，定义线的左端顶点为红色，右端顶点为绿色，只要将这两个顶点颜色值传递给vertex shader，然后vertex shader通过一个varying变量将颜色值传递给fragment shader，那么fragment shader就可以自动的计算这条线段上其他点的颜色，使其平稳的从红色变成绿色。 在变量的命名中有以下约定: attribute变量命名以”a”开头，如attribute vec3 aVertexPosition uniform变量命名以”u”开头，如uniform mat4 uMVMatrix varying变量命名以”v”开头，如varying vec4 vColor WebGL内置变量都是以”gl_”开头的，如gl_Position 本例中的顶点着色器，接收用户输入的顶点数据到aVertexPostion变量，然后将三维的顶点坐标变成四维的齐次坐标，保存到gl_Position变量中，这个变量表示顶点的位置。 片段着色器片段着色器的输入包括： shader源代码 内置特殊变量 用户自定义的varying变量 uniform变量 采样器(sampler): 特殊的uniform变量，用于纹理映射 片段着色器的输出包括： 内置特殊变量： gl_FragColor，表示片段的颜色。 片段着色器最主要的作用就是根据vertex shader的处理结果，计算各个片段的颜色，输出到内置变量gl_FragColor。WebGL中的颜色用一个vec4类型表示，即一个四维向量，每个分量分别对应R,G,B,A,但是需要注意的是，每个分量的值都在[0,1]之间，它们对应[0,255]这种整数值的颜色表示，最后一位是透明度。 在这个例子中，第一句precision mediump float;用来定义一个精度限定符，通过这个精度限定符，着色器编译器就可以知道着色器的变量或者数据类型的最小精度。在WebGL中，所有片段着色器中都必须定义浮点类型数据的精度，这里采用的mediump表示中等精度。 创建Shader现在已经将shader的源代码写好并且放在了&lt;script&gt;标签中，接下来就要利用这些源代码创建Shader程序。 123456789101112131415161718192021222324252627282930313233function loadShaderFromDOM(id) &#123; var shaderScript = document.getElementById(id); if (!shaderScript) &#123;// 如果没有找到DOM则返回null return null; &#125; var shaderSource = ""; var currentChild = shaderScript.firstChild; while (currentChild) &#123; if (currentChild.nodeType == 3) &#123; // 3代表文本节点 shaderSource += currentChild.textContent; &#125; currentChild = currentChild.nextSibling; &#125; var shader; if (shaderScript.type == "x-shader/x-fragment") &#123; shader = gl.createShader(gl.FRAGMENT_SHADER);// 创建新的vertex shader &#125; else if (shaderScript.type == "x-shader/x-vertex") &#123; shader = gl.createShader(gl.VERTEX_SHADER);// 创建新的fragment shader &#125; else &#123; return null; &#125; gl.shaderSource(shader, shaderSource);// 将Shader源码放到Shader对象 gl.compileShader(shader);// 编译Shader if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) &#123; alert(gl.getShaderInfoLog(shader)); return null; &#125; return shader;&#125; 这个函数的作用是：从DOM中读取源码创建Shader对象。一次执行创建一个Shader，一共可以创建两种类型的Shader。 首先通过id找到这个DOM对象，这个DOM对象就是容纳Shader源码的&lt;script&gt;节点。用一个while循环来遍历这个对象的子节点（在本例中其实就只有一个子节点），如果子节点的nodeType属性为3，那么表示这个子节点的类型为文本节点。读取该子节点的文本内容，以字符串的形式保存在shaderSource变量中。之前提到的直接在JavaScript代码中以字符串形式编写Shader源码的方法，两种方法最后得到的结果都是相同的。 现在得到了Shader源码的字符串形式，但字符串还不是一个Shader对象，于是创建一个空的Shader对象。根据在&lt;script&gt;标签中定义的type类型，判断要创建何种类型的Shader对象。创建Shader对象用到WebGL提供的gl.createShader()，这个函数接收一个参数：gl.VERTEX_SHADER表示创建顶点着色器，gl.FRAGMENT_SHADER表示创建片段着色器，创建的Shader对象作为返回值保存在shader变量中。 有了新建的空Shader对象和Shader源码，就可以调用gl.shaderSource()函数，将源码引入到新建的空Shader对象中。到此为止，Shader对象创建完成。然后调用gl.compileShader()函数对Shader进行编译。因为Shader是用GLSL ES编写的，而不是JavaScript这种不需要编译的脚本语言。 最后的if语句是为了检查编译是否成功，gl.getShaderParameter访问gl.COMPILE_STATUS的值，如果是true则表示编译成功，否则编译失败。 将Shader链接成程序上面已经创建了Shader并且编译，但是Shader还需要经过链接以后才能执行。 12345678910111213141516function setupShaders() &#123; vertexShader = loadShaderFromDOM("shader-vs"); fragmentShader = loadShaderFromDOM("shader-fs"); shaderProgram = gl.createProgram();// 创建一个新的空程序 gl.attachShader(shaderProgram, vertexShader); gl.attachShader(shaderProgram, fragmentShader);// 将两个Shader放到程序中 gl.linkProgram(shaderProgram);// 将程序中的所有Shader链接 if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) &#123; alert("Failed to setup shaders"); &#125; gl.useProgram(shaderProgram);// 指示WebGL使用这个程序 shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");&#125; 首先，两次调用上一小节介绍的loadShaderFromDOM()函数，分别得到编译好的vertex shader和fragment shader。然后调用gl.createProgram()创建一个新程序，通过gl.attachShader()函数把编译好的两个Shader放到这个新程序里面，接着调用gl.linkProgram将程序中的两个Shader链接。与检查编译状态类似，gl.getProgramParameter()函数访问gl.LINK_STATUS来检查链接是否完成。到此为止，Shader的编译和链接都已经完成了，通过gl.useProgram()指定WebGL引擎要使用这个程序绘图。最后的gl.getAttribLocation()方法用来获取通用属性索引，将在下一篇博客中详细介绍。 创建BufferWebGL创建的Buffer是内存上的一块区域，它由WebGL来管理。 用户的数据都要先发送到Buffer里面，然后WebGL从Buffer中读取。 123456789101112function setupBuffers() &#123; vertexBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); var triangleVertices = [ 0.0, 0.5, 0.0, -0.5, -0.5, 0.0, 0.5, -0.5, 0.0 ]; gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(triangleVertices), gl.STATIC_DRAW); vertexBuffer.itemSize = 3; vertexBuffer.numberOfItems = 3;&#125; gl.createBuffer()用来创建一个buffer。WebGL可以创建很多个buffer，每个buffer用来专门存放一类数据。gl.bindBuffer将新建的Buffer与Shader的中的一个目标绑定，即告诉Shader要从这个Buffer中获取什么数据。然后定义顶点数据，本例要绘制一个三角形，所以只用传入三个三维的顶点数据。gl.bufferData()将定义的数据上传到缓存中，由于缓存已经绑定了目标，所以第一个参数直接写成目标。后面的itemSize和numberOfItems属性分别表每个顶点包含的坐标数据个数（三维坐标），以及顶点的个数（三角形有三个顶点），加到buffer对象上以便后面调用。关于WebGL的buffer数据管理策略后面的博客中会有更详细的介绍。 绘画的主函数到目前为止，已经准备好了绘画用到的WebGL程序和数据，终于可以开始绘画了。 12345678function draw() &#123; gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);// 设置窗口大小 gl.clear(gl.COLOR_BUFFER_BIT);// 重置窗口颜色 // 下面这两个函数指定数据的导入格式 gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, vertexBuffer.itemSize, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute); gl.drawArrays(gl.TRIANGLES, 0, vertexBuffer.numberOfItems);// 开始绘画&#125; hexogl.viewport定义绘画视口的大小和位置。绘画视口是一个矩形区域，前两个参数定义了视口矩形的左下角顶点，其坐标相对于canvas画布的左下角顶点而言，后两个参数定义了矩形的宽高，以像素为单位。gl.clear()把颜色缓存清除为在下面的startup()函数中用gl.clearColor()函数定义的颜色。这相当于描绘背景色，因为后面只绘画我们定义的三角形以，也只给三角形填充颜色。gl.vertexAttribPointer()用来指定Buffer中数据的引用方法，gl.enableVertexAttribArray()用来激活通用属性索引，最后一个函数是绘画命令。 WebGL程序的一般步骤最后，我们总结WebGL程序的一般步骤： 在HTML代码中加入一个&lt;canvas&gt;标签，在JavaScript代码中引用这个&lt;canvas&gt;标签，创建一个WebGLRenderingContext对象，这个对象包含了所有的WebGL API,一般命名为gl，即gl.function()的方法； 用GLSL ES编写vertex shader和fragment shader的源代码； 用WebGL的API，创建shader对象，然后引入vertex shader和fragment shader的源代码并且编译； 用WebGL的API，创建一个程序，程序中引入编译好的shader object，然后链接这个程序，再指示WebGL如何使用这个程序对象进行绘制； 设置WebGL缓存对象，并把几何对象的顶点数据载入到顶点缓存； 指示WebGL，哪个缓存对应于着色器的属性，最后绘制几何对象。 总结这篇博客很长，介绍了WebGL程序的一般结构。可以发现，有很多代码是为了错误处理或者提高兼容性，所以使整个程序长了很多。这里介绍的有些函数在其他更高级的WebGL程序中都是通用的，如createGLContext, loadShaderFromDOM等，更复杂的功能也是在这个程序的代码上增加一些函数，或者对这里的函数做修改实现的。总之，这个简单程序的结构，是开发WebGL应用程序的基础。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习WebGL(二): WebGL基础知识]]></title>
    <url>%2F2016%2F03%2F24%2F%E5%AD%A6%E4%B9%A0WebGL-%E4%BA%8C-WebGL%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[WebGL中的术语在WebGL中，有一些重要的术语和基本概念。我学习WebGL时，发现很多学习资料都缺少对这些术语和基本概念的详细而明确的解释，导致学习的时候一头雾水，所以在这里先将它们中最重要的部分列出来。 GPU不需要研究GPU的硬件结构和工作原理，我们只需要知道GPU是流水线结构，也就是一级一级的级联结构，数据在GPU中经过一级一级的处理，每一级都会完成相应的操作。 帧缓存帧是一个单位，比如电影就是由很多帧画面连续变换组成。WebGL在浏览器上的一次完整的绘画就产生一帧图像，如果要产生动画效果那就是在一秒钟内快速的进行多次绘画。打开这个例子，可以看到左上角有一个fps数据，这个fps就是帧率，即一秒钟WebGL绘画的次数，fps越高，动画效果越流畅，表明电脑的GPU性能越好。帧缓存就是一个存储器，它保存了最终显示在屏幕上的一帧图像的全部信息。我们绘制图形的第一部是传入数据，数据经过GPU流水线的处理之后，最终到达帧缓存，然后只要访问帧缓存中的数据就可以将图像完整的绘制出来。帧缓存通常至少由以下三个子缓存组成： 颜色缓存(color buffer): 一帧图像是由很多个像素点组成的，图像的信息也就是每个像素点的信息，颜色缓存中保存了每个像素点的颜色信息。 Z-缓存（Z-buffer）： 绘图是在平面上绘图，但绘图的对象是立体的，就像拍照一样，总会有些物体被遮挡住，Z-缓存就是提供这些信息的，根绝这些信息，WebGL不用绘制那些被遮挡的点，它存储的信息就相当于CSS中的z-index属性。 模板缓存（stencil buffer）: 可以用来控制在颜色缓存的某个位置写入操作，一个实际应用的示例是用它来处理阴影。 着色器着色器（Shader）是用户编写的，经过编译和链接后在GPU上运行的程序，它是WebGL最核心的部分。WebGL有两个着色器，分别是顶点着色器(vertex shader)和片段着色器（fragment shader），着色器是用GLSL ES语言编写的，每个着色器的具体功能会在后面介绍。 GLSL ESOpenGL用来编写着色器的语言是GLSL（OpenGL Shading Language），OpenGL ES用来编写着色器的语言是GLSL ES，由于WebGL是基于OpenGL ES 2.0的，所以WebGL也是使用GLSL ES，这是一种类C风格的编程语言。如果需要深入学习这门语言，可以参考这里的官方文档。在博客中没有对这门语言做专门的介绍，但是在用到的地方都会有详细说明。 WebGL中的数据WebGL中的数据需要用到一些矩阵论的知识，主要是矩阵和向量。 齐次坐标在三维空间中，向量是没有位置的，只有长度和方向。正因如此，(1,2,1)既可以表示三维空间中的一个点，也可以表示三维空间中的一个向量。所以如果只给定(1,2,1)这个数据，很难判断是点还是向量。使用齐次坐标可以解决这个问题。齐次坐标是用四维坐标数据来表示三维空间中的点和向量。三维空间中的点(x1,y1,z1)，用齐次坐标就可以表示成(x2,y2,z2,w)，其中x1 = x2/w, y1 = y2/w, z1 = z2/w。由于w的取值不唯一，所以同一点的齐次坐标有多种形式，如(1,2,1)的齐次坐标既可以是(2,4,2)，又可以是(3,6,3)。如果w=0，那么这个齐次坐标表示的就是矢量，否则这个齐次坐标表示的就是一个点，这样就有了明确的区分。 在JavaScript中，坐标使用数组表示，如点(1,2,1)和点(0,1,0)表示成[1,2,1,0,1,0]。对于表示坐标每三个数组元素，我们不妨统一看成是一个向量。使用齐次坐标的另一个更重要的好处是将三维向量变成了四维向量，由于在WebGL中用到的矩阵基本都是四维的，所以将矩阵和向量计算时就非常方便，因为矩阵和向量的运算对于维数是有严格要求的。 坐标变换WebGL中的坐标变换包括三种类型：平移，缩放和旋转，这三种变换都可以用与矩阵的相乘来表示，相乘的矩阵称为变换矩阵，一般都是一个4*4的方阵。为了方便在JavaScript进行矩阵运算，会用到一些JavaScript库。我在学习WebGL时用的是glMatrix，它是专门为了WebGL设计的基于JavaScript的矩阵运算库，比一些通用的矩阵运算库用起来要方便很多。 输入到WebGL的数据用户输入到WebGL的主要是顶点数据。比如，现在要用WebGL绘制一个立方体，那么用户需要输入这个立方体八个顶点的坐标，用户定义坐标时可以用三维的，在WebGL中会自动扩展成四维的其次坐标。WebGL会根据用户输入的顶点数据，自动连接成一个立方体。 WebGL图形流水线由于GPU是流水线结构的，所以WebGL在处理绘图时也是流水线结构，从输入数据开始，经过流水线每个阶段的处理，到最后生成图像信息绘制在屏幕上。一个WebGL程序的组成包括： HTML，CSS和JavaScript： 与HTML相关的主要是&lt;canvas&gt;标签和&lt;script&gt;标签，CSS定义样式，JavaScript负责着色器以外部分的编程 着色器代码： 用GLSL ES编写的vertex shader和fragment shader 3D或2D对象的数据： 即用户输入的数据 WebGL流水线的总体结构图如下所示： 接下来逐步分析WebGL图形流水线的各个阶段。 顶点着色器用户输入到WebGL的，是顶点数据，顶点着色器就是对这些顶点数据进行处理的。比如，对用户输入的顶点数据进行变换，将用户输入的三维坐标自动扩展成四维的齐次坐标，顶点着色器还可以改变各个顶点的位置，进而影响最后绘制出来的几何对象的大小和位置。 图元装配(primitive assembly)所谓图元(primitive)，是WebGL绘图的一些基本单元。WebGL中的图元有三种：点、线和三角形，其他的复杂图形都是由这三种基本图元组合而成的，如绘制一个矩阵，就可以通过绘制两个三角形组合而成。图元装配就是将经过顶点着色器处理后的顶点，装配成基本图元。装配的图元最后不一定都会显示出来，显示区域也是由用户自定义的，比如只显示一个立方体的右上角顶点。对于在显示区域外的图元则要被抛弃，一部分在显示区域内另一部分在显示区域外的图元则要被剪裁掉。 光栅化光栅化的作用就是将图元转换成片段(fragment)，一个片段最后对应的就是屏幕上的一个像素点。 片段着色器片段着色器(fragment shader)就是处理光栅化之后处理片段的，它给片段加上颜色信息。 逐片段操作在fragment shader之后，对每一个片段都要进行一些操作，包括： 裁剪测试：测试决定片段是否位于剪裁矩形中，剪裁矩形可以理解成因为用户自定义显示区域而决定的矩形，剪裁矩形外的片段被抛弃。 多重采样片段操作：修改片段的alpha值和覆盖值，是抗锯齿的一个措施。所谓抗锯齿，是指让两点之间的连线看起来尽量光滑，而不是有很多锯齿。 深度缓存测试： 根据Z-缓存的值丢弃输入的部分片段，即被覆盖的片段不会传到绘制缓存（可以将绘制缓存理解成上面提到的帧缓存）。 融合：把传入片段的颜色与已经在颜色缓存中相应位置片段的颜色进行组合。创建透明对象时需要使用融合技术。 抖动：抖动用来以某种方式排列颜色，得到比实际颜色数更多的颜色。当颜色缓存可用的颜色数有限时，抖动就非常有用。 总结这篇博客对WebGL中常用的术语以及WebGL中用到的数据做了介绍。WebGL中的这些术语与OpenGL是非常相似的，甚至是通用的。WebGL流水线相对复杂，但是理解其大致过程，对于编写WebGL程序也是很有帮助的。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习WebGL(一)：什么是WebGL]]></title>
    <url>%2F2016%2F03%2F22%2F%E5%AD%A6%E4%B9%A0WebGL-%E4%B8%80-%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFWebGL%2F</url>
    <content type="text"><![CDATA[最近看到实验室其他同学在学习OpenGL，看起来非常高大上。本着个人兴趣以及项目需求，也想学习一下WebGL。学习一段时间后，顿悟WebGL之强大！虽然在目前来说，WebGL的使用还不是特别广泛，但可以预见在将来必定有很大用途。于是想把自己的学习心得记录下来，希望有兴趣的朋友一起讨论。在学习WebGL之前，我没有任何计算机图形学的基础，所以为了理解某些内容查阅了很多资料，结合自己的理解，我都会在博客中写出来，与大家共享，所以这套博文非常适合WebGL初学者一起学习讨论。 我学习的参考书： 《WebGL高级编程–开发Web 3D图形》，[美]Andreas Anyuru 著，吴文国 译 《WebGL编程指南》，[美]Kouichi Matsuda, Rodger Lea 著， 谢光磊 译 什么是WebGL？为了搞清楚这个问题，首先都是习惯性的去谷歌一下，然而看了维基百科和官网上的解释之后，感觉似懂非懂。书上的解释是：WebGL是一个用来在Web上生成三维图形效果的应用编程接口。分析这句话：首先WebGL是一个编程接口，即API，也就是说WebGL就是一套可以给我们调用的API，然后，WebGL的作用是在Web上生成三维图形效果的。看到这里好像明白了一点，后来还是自己找了个example去看一下代码，最后我的理解是：WebGL是支持WebGL功能的浏览器给我们提供的一套API，调用这些API可以驱动GPU帮我们在浏览器上绘制3D图形。我们常说CPU是电脑的大脑，那么GPU就是显卡的大脑。我们在买电脑时要看的一个重要参数就是显卡，我们都知道好的显卡能够呈现更好的画质，尤其是在玩游戏时。那么同样的，如果我们能够调用GPU帮我们在浏览器上绘图，那么3D效果肯定要好很多，这也就是我们使用WebGL的一个重要原因。为了让大家感受一下WebGL带来的好处，这里有一个非常棒的例子。这就是用WebGL实现的一个3D小游戏，如此酷炫的3D效果，就是在浏览器中实现的，是不是很棒？！ 而且，WebGL目前已经得到了大部分浏览器的支持。目前支持 WebGL 的浏览器：Firefox 4+, Google Chrome 9+, Opera 12+, Safari 5.1+ and Internet Explorer 11+; 然而, WebGL一些特性也需要用户设备支持。 如何使用API上面提到，WebGL是支持WebGL功能的浏览器给我们提供的一套API，调用这些API可以驱动GPU帮我们在浏览器上绘制3D图形。那么要如何获取和使用这些API呢？要使用这套API，首先要创建一个WebGL绘图环境，创建这个绘图环境的结果是，我们会得到一个WebGLRenderingContext对象，在这个对象中包含了WebGL提供的一些属性和API，供我们使用。 要在浏览器上绘制3D图形，就要使用到canvas标签，这也是创建WebGL绘图环境的一部分。它是一个html5标签，其语义就是一块画布，在这块画布上就可以进行绘制了。现在有很多html5小游戏，就是用到了这个标签。所以，在html代码部分，我们也需要一个canvas标签，然后通过canvas标签来获取WebGLRenderingContext。如下面的代码所示： 12345678910111213&lt;body onload="draw()"&gt; &lt;canvas id="canvas" width="300" height="300"&gt;Your browser does not support the HTML5 canvas element.&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var gl; function draw() &#123; var canvas = document.getElementById("canvas"); gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl") &#125; &lt;/script&gt;&lt;/body&gt; 我们定义了一块宽高都是300px的canvas画布，canvas标签之间的语句是为了在不支持html5的浏览器中显示。在js代码中，我们用document.getElementById()方法获取这个标签，然后用canvas.getContext()方法获取WebGlRenderingContext对象，保存在一个全局变量gl中。然后，通过gl我们就可以调用WebGL的API了。比如，gl.createShader()方法就是WebGL提供的API之一。注意到这里我们传递给getContext()方法的参数有两个，两者其实是等价的。在WebGL标准定稿之前用的是”experimental-webgl”，定稿之后用的是”webgl”，为了浏览器的兼容性，最好两个都使用。用||符号的好处在于，如果第一个语句能够成功获取WebGLRenderingContext对象，就不必执行第二条语句。 WebGL与OpenGL，OpenGL ES 2.0在网上搜索WebGL时，可以看到OpenGL，OpenGL ES 2.0相关的内容。那么这几个之间到底是什么关系呢？相同之处在于，它们都是为了驱动GPU绘图而提供的一套API。现在我将它们各自的特点列举出来对比如下： OpenGL： 1992年发布第一个版本，跨平台在linux,Unix的几个版本，Mac OS X和Windows操作系统平台中使用，主要用于台式机。 OpenGL ES2.0： 由桌面OpenGL的子集组成，适用于移动手机等嵌入式设备的，开放的3D图形标准。 WebGL：2011年发布第一个版本，主要是在Web上使用。建立在OpenGL ES 2.0之上，所以非常类似，最大的不同之处在于WebGL运行在HTML和JavaScript上下文中，而OpenGL ES 2.0 通常用在C/C++、Objective C或Java上下文。 可以看到，OpenGL是最早发布的，是鼻祖，主要适用于台式机，如台式机上的游戏开发。OpenGL ES是OpenGL的子集，而WebGL又基于OpenGL ES2.0而来。三者是相互继承发展的关系。主要区别在于其运行环境和适用范围的不同。 顺便提一下，还有一项技术叫做DirectX，如Directx 11，这是微软多媒体和游戏编程API的名称，它也是可以用来做3D图形编程的，但是这项技术只能用于Windows操作系统，OpenGL与此相比最大的一个好处就是其跨平台性，即可以运行在多种操作系统中。 WebGL如何驱动GPU在WebGL中，除了使用JavaScript之外，我们还需要使用另一种GLSL ES语言，即OpenGL ES Shading Language，主要用来编写着色器（后面介绍）。这是一种类似于C风格的代码，它要经过编译和链接之后，在GPU上执行。而我们知道JavaScript是脚本语言，不需要经过编译和链接的。WebGL集成了多种GPU的编译器，可以确保GLSL ES编译后能在GPU上正确的执行。 总结这篇博客对WebGL的一般性概念做了介绍，并且与OpenGL、OpenGL ES等做了对比，希望对大家初步认识和理解WebGL有帮助。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议之应用层HTTP协议]]></title>
    <url>%2F2016%2F01%2F17%2FTCP%3AIP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E5%BA%94%E7%94%A8%E5%B1%82HTTP%2F</url>
    <content type="text"><![CDATA[前面博客介绍了应用层协议之下的各种协议，现在介绍应用层的HTTP协议，因为这个协议是前端开发中用到的最多的协议。 DNS在介绍HTTP协议之前，先简单介绍一下DNS协议。 DNS(Domain Name Service)提供域名服务，将域名映射到IP地址。如果没有DNS，那需要记住每个网站的IP地址，这是非常不方便的，但是域名就更加方便记忆和使用了。DNS协议基于 UDP，使用端口号 53。DNS服务器是个分层次的系统： 根 DNS 服务器 ：全世界共有 13 台根域名服务器，编号 A 到 M，其中大部分位于美国。 顶级(TLD)DNS 服务器 ：负责如 com 、org 、edu 等顶级域名和所有国家的顶级域名(如 cn 、uk 、jp )。 权威 DNS 服务器 ：大型组织、大学、企业的域名解析服务。 本地 DNS 服务器 ：通常与我们主机最近的 DNS 服务器。 在域名解析的过程中，有迭代查询和递归查询两种方式。 迭代查询：请求主机将需要解析的域名交给本地DNS服务器，如果本地DNS服务器没有，那么本地服务器先去请求根DNS服务器，如果根DNS有则返回，否则本地DNS服务器继续请求顶级DNS服务器，如果顶级DNS服务器有则返回，否则本地服务器继续请求权威DNS服务器。也就是说，由本地服务器分别查询各层的DNS服务器获取结果。 递归查询：请求主机将需要解析的域名交给本地服务器，如果本地服务器没有，那么本地服务器把这个请求交给根DNS服务器，如果根DNS服务器有则返回给本地DNS服务器，如果没有，则由根DNS服务器向顶级DNS服务器发送请求，如果顶级DNS服务器有，则逐级返回到请求主机，否则再由顶级DNS服务器向权威DNS服务器发送请求 HTTP协议HTTP (HyperText Transfer Protocol 超文本传输协议) 基于 TCP，使用端口号 80 或 8080。每当你在浏览器里输入一个网址或点击一个链接时，浏览器就通过 HTTP 协议将网页信息从服务器提取再显示出来，这是现在使用频率最大的应用层协议。 这个原理很简单： 点击一个链接后，浏览器向服务器发起 TCP 连接； 连接建立后浏览器发送 HTTP 请求报文，然后服务器回复响应报文； 浏览器将收到的响应报文内容显示在网页上； 报文收发结束，关闭 TCP 连接。 HTTP协议的特点 HTTP协议构建与TCP/IP协议之上，默认端口号是80 HTTP是无连接无状态的 无连接所谓无连接，是指限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。在实际应用中，有一种Keep-alive连接（下面会继续介绍），他使客户端到服务器端的连接持续有效，当出现对服务器的后续请求时，Keep-Alive功能避免了建立或者重新建立连接。但是HTTP协议本身是无连接的。 无状态所谓无状态，是指协议对于事物处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息。打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP 是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 客户端与服务器进行动态交互的 Web 应用程序出现之后，HTTP 无状态的特性严重阻碍了这些应用程序的实现，毕竟交互是需要承前启后的，简单的购物车程序也要知道用户到底在之前选择了什么商品。于是，两种用于保持 HTTP 连接状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session。 Cookie与SessionCookieCookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。网络服务器用HTTP头向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies 。cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。 cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。 Sessionsession机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。 保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。 经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。 HTTP报文请求报文HTTP请求分为三个部分：状态行、请求头、消息主体 1234&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;&lt;headers&gt;&lt;entity-body&gt; 状态行包括请求方法、请求的URL和使用的HTTP协议版本三个部分。请求的方法以下几种： 方法 说明 支持的HTTP协议版本 请求行例子 GET 如果请求的是文本资源，那就保持原样返回；如果是像CGI（Common Gateway Interface，通用网管接口）那样的程序，则返回执行后的结果。 1.0、1.1 GET /csrfToken HTTP/1.1 POST 传输实体主体 1.0、1.1 PUT PUT方法用来传输文件。就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求的URI制定的位置。 1.0、1.1 HEAD HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。 1.0、1.1 DELETE DELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。 1.0、1.1 OPTIONS OPTIONS方法用来查询针对请求的URI指定的资源支持的方法 1.1 TRACE 让Web服务器端将之前的请求通信环回给客户端的方法 1.1 CONNECT 用于代理服务器 1.1 LINK 建立和资源之间的联系 1.0 UNLINK 断开连接关系 1.0 其中最常用到的是GET请求和POST请求，这也是在前端开发中使用AJAX请求的常用方法。 响应报文HTTP 响应与 HTTP 请求相似，HTTP响应也由3个部分构成，分别是： 状态行：状态行由协议版本、数字形式的状态代码、及相应的状态描述 响应头(Response Header) 响应正文 状态码（Status-Code）都是三位数字的，分为 5 大类共 33 种。 状态码 说明 请求行例子 1xx 表示通知信息的，如请求收到了或正在进行处理 2xx 表示成功 HTTP/1.1 200 OK 3xx 表示重定向 4xx 表示客户端的差错，如请求链接为不存在 HTTP/1.1 404 Not Found 5xx 表示服务器的差错 条件GETHTTP 条件 GET 是 HTTP 协议为了减少不必要的带宽浪费，提出的一种方案。 HTTP 条件 GET 使用的时机 客户端之前已经访问过某网站，并打算再次访问该网站。 HTTP 条件 GET 使用的方法 客户端向服务器发送一个包询问是否在上一次访问网站的时间后是否更改了页面，如果服务器没有更新，显然不需要把整个网页传给客户端，客户端只要使用本地缓存即可，如果服务器对照客户端给出的时间已经更新了客户端请求的网页，则发送这个更新了的网页给用户。 客户端发送： 1234GET / HTTP/1.1 Host: www.sina.com.cn:80 If-Modified-Since:Thu, 4 Feb 2010 20:39:13 GMT Connection: Close 第一次请求时，服务器端返回请求数据，之后的请求，服务器根据请求中的 If-Modified-Since 字段判断响应文件没有更新，如果没有更新，服务器返回一个 304 Not Modified响应，告诉浏览器请求的资源在浏览器上没有更新，可以使用已缓存的上次获取的文件。 12345678HTTP/1.0 304 Not Modified Date: Thu, 04 Feb 2010 12:38:41 GMT Content-Type: text/html Expires: Thu, 04 Feb 2010 12:39:41 GMT Last-Modified: Thu, 04 Feb 2010 12:29:04 GMT Age: 28 X-Cache: HIT from sy32-21.sina.com.cn Connection: close 持久连接我们知道 HTTP 协议采用“请求-应答”模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）；当使用 Keep-Alive 模式（又称持久连接、连接重用）时，Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。 在 HTTP 1.1 版本中，默认情况下所有连接都被保持，如果加入 “Connection: close” 才关闭。目前大部分浏览器都使用 HTTP 1.1 协议，也就是说默认都会发起 Keep-Alive 的连接请求了，所以是否能完成一个完整的 Keep-Alive 连接就看服务器设置情况。 HTTP Keep-Alive 简单说就是保持当前的TCP连接，避免了重新建立连接。 HTTP 长连接不可能一直保持，例如 Keep-Alive: timeout=5, max=100，表示这个TCP通道可以保持5秒，max=100，表示这个长连接最多接收100次请求就断开。 HTTP是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive没能改变这个结果。另外，Keep-Alive也不能保证客户端和服务器之间的连接一定是活跃的，在HTTP1.1版本中也如此。唯一能保证的就是当连接被关闭时你能得到一个通知，所以不应该让程序依赖于Keep-Alive的保持连接特性，否则会有意想不到的后果。 使用长连接之后，客户端、服务端怎么知道本次传输结束呢？两部分：1. 判断传输数据是否达到了Content-Length 指示的大小；2. 动态生成的文件没有 Content-Length ，它是分块传输（chunked），这时候就要根据 chunked 编码来判断，chunked 编码的数据在最后有一个空 chunked 块，表明本次传输数据结束 HTTP Pipelining（HTTP 管线化）默认情况下 HTTP 协议中每个传输层连接只能承载一个 HTTP 请求和响应，浏览器会在收到上一个请求的响应之后，再发送下一个请求。在使用持久连接的情况下，某个连接上消息的传递类似于请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2 -&gt; 请求3 -&gt; 响应3。 HTTP Pipelining（管线化）是将多个 HTTP 请求整批提交的技术，在传送过程中不需等待服务端的回应。使用 HTTP Pipelining 技术之后，某个连接上的消息变成了类似这样请求1 -&gt; 请求2 -&gt; 请求3 -&gt; 响应1 -&gt; 响应2 -&gt; 响应3。 实际应用中，接收方也不必对收到的每个报文都做回复，而是采用累积确认方式：接收者收到多个连续的报文段后，只回复确认最后一个报文段，表示在这之前的数据都已收到。 管线化机制通过持久连接（persistent connection）完成，仅 HTTP/1.1 支持此技术（HTTP/1.0不支持） 只有 GET 和 HEAD 请求可以进行管线化，而 POST 则有所限制 初次创建连接时不应启动管线机制，因为对方（服务器）不一定支持 HTTP/1.1 版本的协议 管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变 HTTP /1.1 要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可 由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如 Chrome 和 Firefox 默认并未开启管线化支持 参考： http://blog.csdn.net/sunansheng/article/details/52056235 https://hit-alibaba.github.io/interview/basic/network/HTTP.html]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议之传输层TCP和UDP]]></title>
    <url>%2F2016%2F01%2F15%2FTCP%3AIP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82TCP%E5%92%8CUDP%2F</url>
    <content type="text"><![CDATA[上一篇博客介绍了网络层，其中最重要的是IP协议，这篇博客继续介绍传输层。传输层主要有两个协议：TCP协议和UDP协议，下面分别介绍。 点到点与端到端计算机网络中经常提到点到点和端到端，但对于这两个概念很多博客上并不会单独解释，根据我查阅的资料和自己的理解，总结如下： 点到点是物理拓扑结构，是网络层的，即两头都是机器，中间通过线路连接，中间可以没有其他机器，IP协议就是解决这点到点之间的通信问题。 端到端是网络连接，中间可能经理多个路由器、主机等，一旦连接建立起来，就形成了端到端的逻辑链路，这条路可能经过了很复杂的物理路线，但两端主机不管，只认为是有两端的连接，TCP和UDP就是提供端到端的服务。 也就是说，点到点是拓扑结构上点到点，端到端是服务上的端到端，可能包含多个点到点。 TCP协议TCP的特性 TCP提供一种面向连接的、可靠地字节流服务 在一个TCP连接中，仅有两方进行彼此通信，广播和多播不能用于TCP TCP使用校验和，确认和重传机制来保证可靠传输 TCP给数据分节进行排序，并使用累计确认保证数据的顺序不变和非重复 TCP使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制 注意：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。 TCP建立连接的三次握手指在建立一个TCP连接时，需要客户端和服务器总共发送3个包 第一次握手：客户端发送一个SYN包，SYN=1，Seq=x，发送完毕后进入SYN_SEND状态 第二次握手：服务器发送回发ACK+SYN包，ACK=1，SYN=1，ACKnum=x+1，Seq=y发送完毕后服务器进入SYN_RCVD状态 第三次握手：客户端再次发送ACK包，SYN=0，ACK=1，ACKnum=y+1，发送完毕后客户端进入EATABLISHED状态，当服务器收到这个包之后也进入ESTABLISHED状态，三次握手结束 TCP断开连接的四次挥手TCP连接的拆除需要发送4个包，称为4次挥手 客户端发送FIN=1的包，表示已经没有数据可以发送了，发送完毕后客户端进入FIN_WAIT_1状态 服务器收到FIN包后发送一个ACK包，表示已经收到客户端关闭连接的请求，但还没有准备好关闭连接，发送完毕后，服务器进入CLOSE_WAIT状态，客户端收到这个请求后，进入FIN_WAIT_2状态，等待服务器关闭连接 服务器端准备好关闭连接，向客户端发送结束连接请求，发送FIN包和ACK包，发送完毕后，服务器进入LAST_ACK状态，表示等待来自客户端的最后一个ACK 客户端收到服务器端的关闭请求，发送一个ACK包，并且进入TIME_WAIT状态，等待可能出现的要求重传的ACK包。服务器端接收到这个确认包之后，关闭连接，进入CLOSED状态。客户端等待某个固定的之间之后，没有收到服务器的ACK，认为服务器已经正常关闭，于是进入CLOSED状态。 TCP如何保证可靠性TCP连接的一个重要特点就是提供可靠的传输服务，主要来说，有以下几点措施保证传输的可靠性： TCP 报文段的长度可变，根据收发双方的缓存状态、网络状态而调整。 当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段，如果不能及时收到一个确认，将重发这个报文段。这就是稍后介绍的超时重传。 TCP 将保持它首部和数据的检验和。如果通过检验和发现报文段有差错，这个报文段将被丢弃，等待超时重传。 TCP 将数据按字节排序，报文段中有序号，以确保顺序的正确性。 TCP 还能提供流量控制。TCP 连接的每一方都有收发缓存。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。 UDP协议UDP是一个简单的传输层协议，UDP不是面向连接的，UDP传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收，当然也不用重发，所以说UDP是无连接的、不可靠的一种数据传输协议。与TCP相比，有以下几个特性： UDP 缺乏可靠性。UDP 本身不提供确认，序列号，超时重传等机制。UDP 数据报可能在网络中被复制，被重新排序。即 UDP 不保证数据报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次 UDP 数据报是有长度的。而 TCP 是一个字节流协议。对于TCP，发送一串数字（1，2，3，4，5），接收时有可能变成两次（1，2）和（3，4，5），或者变成任意接收方式，协议栈只保证接收顺序正确；UDP发送一个分组，接收方要么接收完全失败，要么成功整个分组都会接收到。 UDP 是无连接的，TCP是面向连接的。TCP需要经过三次握手建立连接，而UDP 发送数据报之前不需要经过握手创建连接的过程。 UDP 支持多播和广播。 参考：https://hit-alibaba.github.io/interview/basic/network/TCP.html]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议之网络层]]></title>
    <url>%2F2016%2F01%2F13%2FTCP%3AIP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82%2F</url>
    <content type="text"><![CDATA[上一篇博客介绍了网络接口层，这篇博客介绍位于网络接口层之上的网络层。重点是网络层里面的IP协议、ARP协议，RARP协议和ICMP协议等 IP地址在介绍IP协议之前，先简单介绍一下IP地址 IP地址是一个32位的二进制数，一般分个成4个数字用点连接，如115.156.163.222，将每个数字转换成二进制数，就得到IP地址的二进制数表示形式。IP地址可被看作是分为两部分：网络号和主机号，可以分为A，B，C三类： A类地址：8位网络号+24位主机号 B类地址：16位网络号+16位主机地址 C类地址：24位网络号+8位主机号 当然，这种分类方法是比较浪费的，因为位数太过固定。比如一个单位有500台机器，那么C类地址就不够用了，至少使用B类地址，而B类地址中同一个网络号下包含65536个IP地址，但实际用到的只有500个，造成了非常大的浪费。于是就另一种分法： 1IP = 网络号 + 子网号 + 主机号 也就是从网络号中提取出某几位当成子网号。当然，还有一种更灵活的方式：不固定网络号和主机号的位数，用一个子网掩码来确定网络号，比如： 12IP地址: 115.156.163.222子网掩码：255.255.255.0 将IP地址和子网掩码进行位与，得到的结果就是网络号，余下的位数就表示主机号。 私有地址与NAT技术所谓私有地址，就是在互联网上不使用，而在局域网络中使用的地址。相当于从IP地址中抽了一些出来，只在局域网中使用。比如，对于A类、B类和C类地址，其对应的私有地址范围是： A类：10.0.0.0—10.255.255.255 B类：172.16.0.0—172.31.255.255 C类：192.168.0.0—192.168.255.255 私有地址的一个重要应用就是NAT(Network Address Translation，网络地址转换)技术。在局域网内的一些主机上可以使用私有地址，但由于私有地址只能在局域网内部使用，如果需要和因特网上的主机通信时，就需要使用NAT技术将内网使用的内网IP地址转换成可以在互联网上使用的全球IP地址，然后与因特网连接，这就实现了内网的数台主机使用了同一个全球 IP 地址在上网。在不同的内网上，都可以使用相同的私有地址，只要不同的内网对外有不同的全球IP地址即可。这有助于缓解 IP 地址空间枯竭的问题，同时实现了贷款共享。 IP网际协议前一篇博客中提到，以太网解决了子网内部的点对点通信，那么IP协议依靠IP地址和路由解决了多个局域网的通信问题。IP协议位于网络层，它是 TCP/IP 协议族中最为核心的协议，所有的 TCP、UDP、ICMP 及 IGMP 数据都以 IP 数据报格式传输。IP 协议提供的是无连接、不可靠的数据报传送服务。 所以无连接，是指IP 协议对每个数据报的处理是相互独立的。如果发送方向接收方发送了两个连续的数据报（先是 A，然后是 B），每个数据报可以选择不同的路线，因此 B 可能在 A 到达之前先到达。 所谓不可靠，是指IP协议不能保证IP数据报能成功地到达目的地，它仅提供传输服务。当发生某种错误时，IP 协议会丢弃该数据报。传输的可靠性全由上层协议来提供。 IP路由选择如果发送方与接收方直接相连（点对点）或都在一个共享网络上（以太网），那么 IP 数据报就能直接送达。 而大多数情况则是发送方与接收方通过若干个路由器(router)连接，那么数据报就需要经过若干个路由器的转发才能送达，它是怎么选择一个合适的路径来”送货”的呢？ IP 层在内存中有一个路由表，路由表存储着指向特定网络地址的路径。当收到一份数据报并进行发送时，都要对该表进行搜索： 1、搜索路由表，如果能找到和目的 IP 地址完全一致的主机，则将 IP 数据报发向该主机； 2、搜索路由表，如果匹配主机失败，则匹配同子网的路由器(这需要子网掩码的协助)。如果找到路由器，则将 IP 该数据报发向该路由器； 3、搜索路由表，如果匹配同子网路由器失败，则匹配同网络号路由器，如果找到路由器，则将该 IP 数据报发向该路由器； 4、如果以上都失败了，就搜索默认路由，如果默认路由存在，则发报； 5、如果都失败了，就丢掉这个包； 6、接收到数据报的路由器再按照它自己的路由表继续转发，直到数据报被转发到目的主机； 7、如果在转发过程中，IP 数据报的 TTL（生命周期）已经被减为 0，则该 IP 数据报就被抛弃。TTL设定了一个初始值，每转发一次，TTL的值减1。 ARP协议当主机通过数据链路发送数据的时候， IP数据报会先被封装为一个数据帧 ，而 MAC地址会被添加到数据帧的报头。MAC地址是物理地址，是不变的。 ARP便是在这个过程中通过目标主机的 IP地址，查询目标主机的 MAC 地址。 ARP 缓存表使用过程： 当主机要发送一个 IP 数据报的时候，会首先查询一下自己的 ARP 缓存表； 如果在 ARP 缓存表中找到对应的 MAC 地址，则将 IP 数据报封装为数据帧，把 MAC 地址放在帧首部，发送数据帧； 如果查询的 IP－MAC 值对不存在，那么主机就向网络中广播发送一个 ARP 请求数据帧，ARP 请求中包含待查询 IP 地址； 网络内所有收到 ARP 请求的主机查询自己的 IP 地址，如果发现自己符合条件，就回复一个 ARP 应答数据帧，其中包含自己的 MAC 地址； 收到 ARP 应答后，主机将其 IP - MAC 对应信息存入自己的 ARP 缓存，然后再据此封装 IP 数据报，再发送数据帧。 RARP协议RARP 与 ARP 是相反的关系，用于将 MAC 地址转换为 IP 地址。对应于 ARP，RARP 请求以广播方式传送，而 RARP 应答一般是单播传送的。 某些设备，比如无盘机在启动时可能不知道自己的 IP 地址，它们可以将自己的 MAC 地址使用 RARP 请求广播出去，RARP 服务器就会响应并回复无盘机的 IP 地址。 ICMP协议通信过程中的发生各种问题时，ICMP 将问题反馈，通过这些信息，管理者可以对所发生的问题作出诊断，然后采取适当的措施去解决它。比如测试网络是否通畅时经常用到ping 程序，就是基于ICMP协议的工具。 IGMP协议IGMP 是用于管理多播组成员的一种协议，它的作用在于，让其他所有需要知道自己处于哪个多播组的主机和路由器知道自己的状态。只要某一个多播组还有一台主机，多播路由器就会把数据传输出去，这样，接受方就会通过网卡过滤功能来得到自己想要的数据。 为了知道多播组的信息，多播路由器需要定时的发送 IGMP 查询，各个多播组里面的主机要根据查询来回复自己的状态。路由器来决定有几个多播组，自己要对某一个多播组发送什么样的数据。 参考资料：http://blog.csdn.net/sunansheng/article/details/52056024]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议之网络链路层]]></title>
    <url>%2F2016%2F01%2F10%2FTCP%3AIP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E7%BD%91%E7%BB%9C%E9%93%BE%E8%B7%AF%E5%B1%82%2F</url>
    <content type="text"><![CDATA[上一篇博客中介绍了ISO七层模型和TCP/IP参考模型。从这篇博客开始，将从下向上依次介绍网络接口层、网络层、传输层、应用层中的主要协议。 网络接口层网络接口层有时也可以称为链路层，它位于TCP/IP参考模型的最底层。上篇博客提到，网络接口层里面传输的数据称为帧，它是从上面开始一层层封装而来的。网络接口层的主要作用有： 在两个网络实体之间提供数据链路的建立、维持和释放的管理 在发送端从网络层拿到IP数据报后封装为帧，在接收端将帧解析为IP数据报发送给网络层 控制帧的传输，包括处理传输差错、调节发送速率与接收方相匹配 控制帧的传输差错控制数据链路层的一个重要功能就是差错控制，主要有以下几个方面： 1. 反馈重发接收方通过对差错编码(奇偶校验码或 CRC 码)的检查，可以判定一帧在传输过程中是否发生了差错。一旦发现差错，一般可以采用反馈重发的方法来纠正。这就要求接受方收完一帧后，向发送方反馈一个接收是否正确的信息，使发送方据此做出是否需要重新发送的决定。发送方仅当收到接收方已正确接收的反馈信号后才能认为该帧已经正确发送完毕，否则需要重发直至正确为止。 2. 计时器如果某一帧发送出现问题，一直不能发送成功，为了避免传输过程停滞不前，通常引入计时器 (Timer) 来限定接收方发回反馈消息的时间间隔。当发送方发送一帧的同时也启动计时器，若在限定时间间隔内未能收到接收方的反馈信息，即计时器超时(Timeout)，则可认为传出的帧以出错或丢失，就要重新发送。 3. 序号由于同一帧数据可能被重复发送多次，就可能引起接收方多次收到同一帧并将其递交给网络层的情况。为了防止这种情况，可以采用对发送的帧编号的方法，即赋予每帧一个序号，从而使接收方能从该序号来区分是新发送来的帧还是重发的帧，以此来确定要不要将接收到的帧递交给网络层。 流量控制在数据收发双方，会有一个缓存区，用来暂存收发的数据。由于收发双方各自使用的设备工作速率和缓冲存储空间的差异，可能出现发送方的发送能力大于接收方接收能力的现象，此时若不对发送方的发送速率做适当的限制，前面来不及接收的帧将被后面不断发送来的帧“淹没”，从而造成帧的丢失而出错。流量控制实际上是对发送方数据流量的控制，使其发送速率不超过接收方的速率。所以需要一些规则使得发送方知道在什么情况下可以接着发送下一帧，而在什么情况下必须暂停发送，以等待收到某种反馈信息后再继续发送。这就是流量控制。 差错控制和流量控制不仅在网络接口层中，在其他层中也有使用，它们保证了数据传输的可靠性和稳定性。 以太网以太网协议是运行在网络接口层上的一种协议，是广泛应用的一种局域网技术，用来构建局域网。经常听到说以太网，其实就可以认为是运行了以太网协议的局域网。以太网解决了子网内部的点对点通信 与以太网对应的还有一个IEEE802.3提供的标准，与以太网协议有所不同，主要是帧的格式上不同，实现的功能基本相同。 在以太网和IEEE802.3中，都会帧的长度有效值，其最大值分别为1500字节和1492字节，称为MTU(最大传输单元)。如果一个IP数据报的长度超过了MTU，那么要拆分成两个或多个帧进行传输。前面提到，从应用层到网络接口层，每一层都要对原始数据封装一些附加信息，所以在1500字节的MTU里面，有一部分都是各层的附加信息，剩下的才是真正需要发送的数据。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议]]></title>
    <url>%2F2016%2F01%2F08%2FTCP%3AIP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[本科的时候学习计算机网络，接触过各种协议，如TCP, UDP, ARP, RARP, HTTP等等。由于课程设置的需求，当时也没有完整、系统的学习。如今在前端开发中，经常会用到HTTP协议，在搜索“HTTP协议”这个关键字的时候，总会看到各种相关的协议，于是就系统的整理了一下。 ISO七层模型学习过计算机网络的同学都知道，计算机网络有一个非常著名的ISO七层模型，从下往上分为： 物理层：二进制新号 数据链路层：接入介质，如光纤 网络层：寻址和最短路径 传输层：端到端连接 会话层：互联主机通信 表示层：数据表示 应用层：处理网络应用 在每一层，都有对应的协议。所谓协议，就是通信双方约定的一种规则，比如A发送数据给B，约定一个规则，只要数据中遇到010100这个序列，就代表发送结束。正式这种规则，才能保证通信稳定有效的进行。 HTTP是属于应用层的协议，也就是最顶层。如下图的示例，当H1向H2发送一个HTTP请求时，表面上来看好像是这个请求直接横向的从H1发送到了H2，但其实是H1要发送的数据，从上到下一层层经过处理和封装，最后经过物理通信经过传输介质发送到H2，然后再H2中再从下往上一层层解析数据，最终将H1发送的数据送到H2顶层。也就是说，对于调用者来说，是走了一条直线，如图中蓝线所示，不用关心下面的过程，而实际上是走了一条折线，如图中红线所示 TCP/IPISO七层模型虽然是官方指定的标准，但是实现起来比较复杂，而且也有一些冗余的部分，实际上用的往往是另一种参考模型，称为TCP/IP参考模型。与ISO七层模型相比，TCP/IP参考模型只有四层，它们的对应关系如下图： 这四层里面，每一层都包含一些协议，TCP/IP协议就是这些协议的总称。需要注意的是，TCP/IP不是只某一个协议，而是一个协议族的总称。从下往上，包含的协议有： 网络接口层：以太网协议 网络层：IP协议，ARP协议，RARP协议，ICMP协议等 传输层：TCP协议和UDP协议 应用层：常见的有HTTP, FTP,DNS和TELNET协议 与ISO七层模型一致的是，数据发送时，在发送方数据也会从上往下通过每一层，每一层都会给数据加上一些附加信息，这个过程称为封装。比如运行在TCP协议之上的HTTP协议发送了一个数据包，那么： 从应用层的HTTP到传输层的TCP时，TCP协议会在这个数据包上附加一些信息，这个数据包在传输层中称为一个TCP段 从传输层的TCP到网络层的IP时，IP协议会在这个数据包上附加一些信息，这个数据包在网络层中称为一个IP数据包 从网络接口层层的IP到链路层的以太网协议时，又会在这个数据包头部附加一些信息，此时数据包称为帧 在接收方收到这个帧后，又会从网络接口层逐层往上，检查比去掉对应层次的附加信息，最后还原数据包，这个过程与封装的过程正好相反，称为分用 为什么要分层呢？这是因为计算机网络是一个极其复杂的系统，每一层都会完成具体的功能，正是通过这种分层的协作，才能保证计算机网络稳定、高效的传输。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的面向对象之继承]]></title>
    <url>%2F2015%2F12%2F18%2FJavaScript%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[上一篇博客讨论了JavaScript中的封装，这篇博客讨论JavaScript中的继承。所有的讨论基于下面的例子： 12345678910function Person() &#123; this.sayHello = function() &#123; console.log('say hello'); &#125; &#125;Person.prototype.country = 'China';function Employee(_id) &#123; this.id = id&#125; 我们要让Employee来继承Person，下面分别介绍JavaScript中继承的实现方法。 构造函数绑定继承这种方法直接使用call或者apply方法，在子对象构造函数中调用父对象的构造函数：123456789101112131415function Person() &#123; this.sayHello = function() &#123; console.log('say hello'); &#125; &#125;Person.prototype.country = 'China';function Employee(_id) &#123; Person.call(this, agruments); this.id = _id;&#125;var Bob = new Employee(12);Bob.sayHello(); // 'say hello'console.log(Bob.country); // undefined 在Employee构造函数中通过call方法调用了Person的构造函数，这样Employee产生的对象就继承了Person中的sayHello方法。但是，这种方法一个缺点是不能继承父对象原型中的属性和方法，比如对于Person.prototype中的country属性，Bob对象就不能继承。此外，arguments参数传递时也必须注意参数的顺序，尤其是在Person对象中也需要传入参数时。 利用对象实例的prototype继承将子对象的构造函数的prototype指向父对象的实例： 12345678910111213141516function Person() &#123; this.sayHello = function() &#123; console.log('say hello'); &#125; &#125;Person.prototype.country = 'China';function Employee(_id) &#123; this.id = _id;&#125;Employee.prototype = new Person();Employee.prototype.constructor = Employee;// constructor修正var Bob = new Employee(21);Bob.sayHello(); // 'say hello'console.log(Bob.country); //'China' 这里直接将Employee类的prototype指向了Person的一个实例，所以Employee构造函数产生的对象实例中，会包括Person对象所有方法，包括原型中的方法。这里需要注意的是对于constructor属性的修正。构造函数和其原型之间是通过prototype和construcotr两个属性确定关系的：构造函数的prototye属性指向原型，原型的constructor属性指向构造函数。由于将Employee的prototype属性赋成了一个Person的实例，所以其原型被完全覆盖，此时如果不做修正，那么Employee.prototype.constructor其实是指向了Person构造函数，所以必须手动的将Employee.prototype.constructor修正为Employee。如果不做修正，虽然可以继承，但是对应关系始终是错的（如果是直接将prototype赋值一个对象，那么不需要做修正，会自动赋constructor）。 直接利用prototype的prototype继承上面的方法是将实例赋值给prototype，这种方法是跳过实例化，直接将prototype赋值给prototype： 12345678910111213141516function Person() &#123; this.sayHello = function() &#123; console.log('say hello'); &#125; &#125;Person.prototype.country = 'China';function Employee(_id) &#123; this.id = _id;&#125;Employee.prototype = Person.prototype;// 仅有此处代码不同Employee.prototype.constructor = Employee;// constructor修正var Bob = new Employee(21);Bob.sayHello(); // 'say hello'console.log(Bob.country); //'China' 这两种方法非常类似，只有一句代码不同，但是两者之间还是有很大差别的，差别的分析又要回到JavaScript中对象的引用原理上来。在第一个方法中，重新实例化了一个Person对象，Employee.prototype指向的是一个Person实例，而Person.prototype仍然指向其原型，所以Person.prototype和Employee.prototype其实是指向了两个不同的地方，这样带来的问题是效率要低一点，因为实例化了对象并且分配了内存。而在这种方法中，直接将原型赋给了原型，其实就没有重新分配内存，Employee.prototype和Person.prototype指向同一个对象，所以形成了一种紧耦合的关系，即修改Employee的原型时，Person的原型也会跟着改变。 顺便提一下，prototype是针对函数的，所有的函数都有一个prototype属性。实例的对象引用了构造函数的prototype原型中的属性和方法，但是对象实例一般并不会直接修改构造函数的prototype中的属性和方法，除非是引用类型的属性和方法。如若这里将Bob实例的country属性改成了’America’，并不会影响到构造函数原型中的country属性，因为这样会自动给Bob实例赋一个country属性覆盖掉原型中的country属性，而不会修改prototype。但是如果country属性是一个引用类型，那么所有其他引用该属性的对象都会跟着改变。 所有对象都有一个constructor属性，并且指向创建当前对象的构造函数，并且对于每个函数的prototype，这个prototype的constructor属性指向这个函数。 小结继承是JavaScript中的重要内容，要弄清楚对象之间的继承关系。这里提出了三种继承的方法，实际的继承方法还有更多，在理解继承时，弄清楚原型链非常重要！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>读书笔记, JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的面向对象之封装]]></title>
    <url>%2F2015%2F12%2F13%2FJavaScript%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[上一篇博客中，对面向对象的三大特征以及其他重要概念做了介绍，接下来将一般化的面向对象概念引入到JavaScript语言中进行探索，介绍JavaScript语言中的一些与面向对象相关的方法。首先，必须明确JavaScript并不是一门面向对象的语言，但是在JavaScript中确实有很多对象的运用，并且有很多类似于面向对象的方法。我写了三篇博客分别讨论JavaScript中的封装，继承和多态，这里首先讨论封装。 在JavaScript中，相对于对象而言，封装时并没有做到数据隐藏，因为在JavaScript中对象的所有属性和方法都可以被用户访问，所以在JavaScript中经常可以看到直接修改属性值，而不是通过暴露的接口来修改属性值，如直接通过person.name = &#39;Bob&#39;而不是person.setName(&#39;Bob&#39;)。而相对于构造函数而言，只有暴露在this上的属性和方法才是外部可以直接访问的，构造函数内部直接定义的变量是不能被外部访问的。接下来分别讨论在JavaScript中构造对象的方法。 直接构造对象要封装一个对象，最简单的方法是直接用{}构建一个对象，当然也可以用new Object，但是使用{}更为简单。如创建一个Person对象： 1234var Person = &#123; name: 'Bob', age: 21&#125;; 直接构造对象的方法简单直观，适用于简单构建对象，不需要考虑继承和复用的情况，对象的所有属性和方法都可以被外部访问。 工厂函数模式工厂函数模式是通过一个工厂函数来创建对象。对象是key-value的集合，工厂函数里面已经指定了返回对象的key，用户使用工厂函数时只需按照约定的顺序传入对应的value值，然后工厂函数就会返回相应的对象。如下面的Person工厂函数： 12345678function Person(_name, _age) &#123; return &#123; name: _name, age: _age &#125;&#125;var Bob = Person('Bob', 21); 这里工厂函数已经预定义了name和age属性，用户直接调用这个工厂函数，按照顺序传入姓名和年龄的值，那么返回的就是包含了这两个属性值的对象。 这种工厂函数模式通过函数式调用的方式产生对象，在需要产生多个同类对象时用起来非常方便，但是缺点是产生的多个对象之间没有明显的关联性，而且在一般的面向对象中，也是通过new关键字这种构造函数式调用的方式产生对象。 构造函数模式当然，在JavaScript中也有一般面向对象中的构造函数模式来封装对象。Java中的构造函数是类中定义的，与类名相同且不返回任何返回值的函数。在JavaScript中没有类的概念，但是在JavaScript中函数也是一个对象，利用这一点，构造函数就是直接定义的一个函数，如下面的Person构造函数： 12345678910function Person(_name, _age) &#123; this.name = _name; this.age = _age; this.sayHello = function()&#123; console.log('say hello') &#125;&#125;var Bob = new Person('Bob', 21);var Alice = new Person('Alice', 21); 由于函数也是一个对象，所以有this属性，直接给this的属性赋值。构造对象时，按照顺序输入属性的value值（这一点与共产函数模式是相同的），然后再加上new关键字。 上面提到工厂函数模式不能体现同一个类型的多个对象之间的关联性，那么构造函数就很好的解决了这个问题。使用构造函数产生的对象都有一个constructor属性，指向构造函数，所以通过这个属性就能体现出关联性，如： 1console.log(Bob.constructor == Alice.constructor) // true 顺便提一下，还可以通过instanceof来体现对象和构造函数的联系，如： 1Bob instanceof Person;//true 构造函数模式的改进构造函数模式的存在一个问题：利用构造函数模式产生的对象，每个对象都是完全新建了一个副本，这会造成内存的浪费。比如上例中的Bob和Alice对象，两者都有一个sayHello方法，这两个方法是完全相同的，但是在内存中却创建了两次，可以通过下面的代码来验证： 1console.log(Bob.sayHello == Alice.sayHello) // false sayHello是一个函数，也是一个对象，在JavaScript中，对象都是引用。这里返回了false，说明有两个对象副本，即分别在内存中创建了两个对象，这是一种内存浪费，可以通过prototype属性来改进： 12345678910function Person(_name, _age) &#123; this.name = _name; this.age = _age;&#125;Person.prototype.sayHello = function()&#123; console.log('say hello');&#125;var Bob = new Person('Bob', 21);var Alice = new Person('Alice', 21); 此时如果运行： 1console.log(Bob.sayHello = Alice.sayHello) // true 这里将sayHello方法放在了prototype属性中，这个构造函数的产生所有对象都直接从这里引用，所以返回true。这也说明在内存中只创建了一个副本，节省了内存空间，尤其是在需要大量产生同类对象时。在jQuery的源码中，jQuery对象的很多方法都是放在了prototype属性中，这样构造jQuery对象时就可以大量节省内存空间。 小结这里主要提出了三种构造对象的方法：直接构造，工厂函数，构造函数；以及一种构造函数模式的改进方法：利用prototype属性。下一篇博客讨论JavaScript中的继承。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>读书笔记, JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象三大基本特征及其他概念]]></title>
    <url>%2F2015%2F12%2F11%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81%E5%8F%8A%E5%85%B6%E4%BB%96%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[学习前端开发以来，在JavaScript相关的书籍中总会看到对象、类、继承等关键词。JavaScript确实提供了很多对象，但是并不是一门真正的面向对象语言。但是，面向对象是一个程序员所必须了解的，而且更进一步，应当在JavaScript中运用面向对象的思想和方法。最近看了一本关于面向对象的编程书，对面向对象的概念有了更深的理解。这篇博客除了记录书中的重点内容之外，还会将面向对象的思想方法与JavaScript进行对比。 书本信息 书名： 写给大家看的面向对象编程书（第三版） 作者： [美] Matt Weisfeld 出版社： 人民邮电出版社 ISBN： 978-7-115-19776-4 关于面向对象什么是对象从最基础的概念讲起，什么是对象？对于所有的程序员来说，对于对象这个概念应当都不陌生。生活中的任何东西都可以看成是一个对象。比如，一个人可以看成是一个对象。那么对象包括什么？我的理解是对象就是一个包含多个key-value键值对的集合。这个集合中，根据value值的性质，又可以分成两个部分：属性和方法。所谓属性，就是value值是一个基本类型或者其他对象，是一个静态的部分。所谓方法，其value值是一个函数，也就是一个动态的部分。 面向对象与面向过程面向过程设计，也叫结构化设计，其核心是过程，即按照过程划分。先分析出解决问题所需要的步骤，然后用函数将这些步骤一个个实现，最后按照顺序依次调用即可。在这里，属性和方法是分开的，即函数和变量没有封装。 面向对象设计，其核心是功能，即按照功能划分。将解决问题所需要的功能，划分成各个对象，一个对象就类似于一个系统，这个系统提供一些同类的功能，在对象里面同时封装了属性和方法，解决问题时直接调用对应的一个或者多个对象即可。 关于对象的重要概念类类是创建对象的模板。类本身也可以当成一个对象来看待，其中包括一些属性和方法，用类创建对象时，对象就会含有类所定义的所有方法和属性。比如下面是一个类的定义： 1234567public class Person &#123; private String name; public String getName() &#123; return name; &#125;&#125; 这里定义了一个名为Person的类，类里面含有一个属性name和一个方法getName，如果要用这个类创建一个对象，那么可以用new关键字，执行代码： 12Person p new Person();p.getName(); 这里先通过new关键字创建了一个Person类型的p对象，那么这个p对象就自然有了name属性和getName方法，然后调用了这个对象的getName方法。 面向对象的三大基本特征封装在一个对象中，有很多属性和方法，但是这个对象并不会将所有的属性和方法都全部暴露给外部，对象只公开了用户与之交互所需要的接口，而与对象使用无关的细节则对其他对象隐藏。也就是说，封装会将很多属性和方法放在一个对象里面，但是只公开一些方法供外部调用，所有属性和其他的方法是隐藏的，用户并不可见，与此相对应的概念就是数据隐藏。 上面提到，数据隐藏时要将所有的属性都设置为private（表示私有），只有一些方法才是对外公开的。那么当属性全部隐藏后，如何才能访问或者修改属性呢？都应该通过方法来实现。比如上面的例子中，name属性是隐藏的，要访问这个属性，只能通过getName这个公开的方法类实现。 与封装相关的两个概念是接口和实现： 所谓接口，是对象暴露给用户的方法，即公开的方法。对于用户来说，只要知道这个接口的返回类型、方法名和参数列表。用户就直接访问对象的接口，实现相应的功能。比如上例中的getName方法就是一个接口。 所谓实现，是与接口相对应的。一个接口所完成的功能，可能需要很多复杂的操作组合而成。这些复杂的操作可能需要很多其他的方法和属性的协作，这些细节的操作也都在对象中，只是没有公开出来，这些细节就称为实现。 在程序开发中，实现是可能改变的，比如后来程序员发现了一个更简洁的实现方法，使调用的函数个数更少，那么就会去修改这些实现的函数。但是只要保证接口不变，即返回值、方法名和参数列表不变，那么实现的改变对于用户来说是没有影响的，用户关心的仅仅是接口而已。 继承所谓继承，就是一个类B可以继承另一个的类A的属性和方法，类A成为超类或者父类，类B成为子类。注意，继承虽然是类与类之间的概念，但是用类创建对象时，对象也含有了类的所有属性和方法。在Java中，可以用extend关键字实现类的继承。如： 123public class Worker extends Person&#123; private workId;&#125; 在这里新建的Worker类就继承了Person类，含有Person类的所有属性和方法。 父类和子类的继承关系可以是多层的，即子类也可以是其他子类的父类，就如同一棵节点树一样，是一个层次结构。在这种层次结构中，越往上的类应该是越抽象的，越往下越具体，只有按照这种设计原则，才能真正将类的继承关系用好，比如Worker类继承自Person，而Worker又可以向下被maleWorker和femaleWorker类继承。上面的类越抽象，就可以被更多的类继承，但同时也会是继承关系更复杂，在实际使用中要根据实际需要来设计继承的层级关系。 多态在父类中定义了方法，在子类中也定义了同名的方法，那么子类的同名方法就会覆盖同名的方法。在实际使用中，往往父类只是给出了这个方法的接口，在Java中也就是abstract： 1234public abstract class Shape &#123; private double area; public abstract double getArea();&#125; 在子类Circle中：12345678910public class Circle extends Shape &#123; double radius; public Circle(double r) &#123; radius = r; &#125; public double getArea() &#123; area = 3.14 * (radius * radius); return (area); &#125;&#125; 在子类Rectangle中： 123456789101112public class Rectangle extends Shape &#123; double length; double width; public Rectangle(double l, double w) &#123; length = l; width = w; &#125; public double getArea() &#123; area = length * width; return (area); &#125;&#125; 在父类Shape中，只给出了getArea方法的抽象定义，而在子类Circle和Rectangle中都各自实现了这个方法，并且实现的方式是不同的，这就是多态。简单的说，就是继承自同一个父类的多个子类，有同名的接口但却有不同的实现和功能。 面向对象的其他概念以上介绍的三个概念：封装，继承和多态，是面向对象的三大特征。结合上面的Shape类的例子，再介绍几个其他概念。 构造函数如果一个方法与所在的类同名，并且没有提供任何类型的返回参数，那么这个函数成为构造函数，比如在Rectangle类中的Rectangle函数。构造函数是初始化类创建一个对象的入口函数，它的主要功能包括三个方面： 规定了用这个类构造一个对象时应当传入的参数列表。比如在Rectangle类中指明了double类型的l参数和w参数。要用这个类创建一个对象，就要传入这两个参数，如 Rectangle rec new Rectangle(2.5, 1.3)。 将对象设置为稳定、安全的初始状态。如在Rectangle类中，构造函数Rectangle将传入的l参数和w参数赋给length和width变量，这样就可以确保这两个变量是有实际值的，其他方法访问时就不会报错。 初始化时分配内存，即给新创建的对象分配内存。 注意到在第一个Person类中，并没有给出构造函数，但是也可以正常的构造对象。这是因为如果在编写的类中没有明确给出构造函数，那么系统会提供一个默认的构造函数。如果这个类是继承的，那么默认的构造函数就是父类的构造函数。如果定义的类没有任何继承，那么在Java中会调用Object类的构造函数。 重载介绍重载之前要先介绍函数签名的概念：函数签名由方法名和参数列表两部分组成。所谓重载，是指同一个方法名对应的多个实现。即在一个对象内部，可能有多个名为getArea的方法，只是他们的函数签名不同，在这里其实也就是参数列表不同了，如double getArea()和double getArea(doubel radius)。同样的，重载也适用于构造函数，即可以存在多个构造函数。重载的一个好处就是允许程序员多次使用同一个方法名。 抽象类所谓抽象类，就是不能直接被初始化的类，比如上例中的Shape类。因为Shape类中有一个抽象方法getArea，这个方法并没有实现，所以直接用new去初始化是不能正确执行的，必须要有子类实现了这个方法，才能通过new这个子类创建对象。只要包含了一个或者多个没有提供任何具体实现的方法，即抽象方法，那么这个类就是抽象类。 接口这里介绍的接口与对象中的接口不同，它是抽象类一级的概念。如： 1234public interface Nameable &#123; String getName(); void setName(String aName);&#125; 接口是保证契约的有效方法。所谓契约，可以理解成接口的规范，其实就是一组抽象方法的集合，与抽象类有类似的地方。要实现一个接口，用到implements关键字： 12345public class Dog implements Nameable &#123; private String name public getName() &#123;return (name)&#125; void setName(aName) &#123; this.name = aName &#125;&#125; 与抽象类相比，接口的区别是：抽象类不仅可以提供抽象方法（即接口），还可以提供方法的实现，简单的理解是函数的参数列表后面带有中括号，并且通过extends关键字扩展子类再实例化对象；而接口仅仅提供抽象方法，不提供方法的实现，通过implements关键字实现。 与对象相关的作用域与对象相关的作用域主要有三种： 局部作用域：在对象中方法内部定义的变量，只有对象中的该方法内部可以访问。对象中的方法就是一个函数，这个函数就限定了一个作用域范围，这就是局部作用域，在这里定义的变量就是局部变量，是所有作用域中最小的一个。 对象作用域：在对象中定义的变量，与方法的定义在同一个层级上，这里定义的变量是整个对象都可以访问的，对象的属性就可以理解成对象作用域中的变量，是对象限定的作用域范围。 类作用域：在类中定义并且声名了static的变量，所有的对象都只会引用但不会重新创建这个变量的副本，这个变量在该类的所有对象中都是可以访问，这就是类所限定的作用域。如果类中没有声名static，那么所有的对象都会重新创建这个变量的副本，就是对象作用域了。 组合某个对象由其他对象组成，而且这些对象作为对象的属性包含在内。就是属性的类型除了基本类型如String外，还有可能是一个对象类型。如汽车这个对象就有发动机、方向盘等对象组合而成。 组合又可以细分成两种类型：聚集和关联，这两个概念容易混淆。聚集是由其他对象组成的复杂对象，当一个对象希望另一个对象来为它提供某个服务时则是关联。我的理解是，聚集就是最直观意义上的组合，是这个对象的成分中包含了被聚集的对象，比如计算机的机箱这个对象，会包括硬盘、显卡等对象，因为计算机的机箱对象是由这几个对象组合而成的，称为聚集。所谓关联，就是对象A中包含了对象B，当对象B并不是对象A的逻辑组成部分，只是对象B出现在对象A的属性中且为对象A服务。比如，机箱对象中，也会包含键盘对象，但键盘对象明显不是机箱对象的一部分（如果是的话那就是聚集了），只是键盘对象也在机箱对象中作为一个属性出现，因为机箱对象需要键盘对象的服务，这种关系称之为关联。 is-a与has-a的关系is-a关系是用来描述继承的，在类的继承中，子类跟父类是一个严格的is-a关系。如，狗这个子类继承了哺乳动物这个父类，那么狗is a哺乳动物，is-a翻译成中文就是“是一个”的意思。 has-a关系是用来描述组合的。比如，汽车这个对象里面包含了发动机这个对象，那么，汽车就has a发动机，has-a翻译成中文就是“有一个”的意思。 is-a和has-a被用来形象的描述继承和组合，这两种方法是面向对象程序设计中实现重用的重要机制，当然两者之间的差别也是很容易区分的。 小结这篇博客总结了面向对象的所有概念，是看书后的总结，下一篇博客会将这些面向对象的概念映射到JavaScript中。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记, JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOCTYPE与HTML, XHTML, HTML5和XML]]></title>
    <url>%2F2015%2F11%2F28%2FDOCTYPE%E4%B8%8EHTML%2C%20XHTML%2C%20HTML5%E5%92%8CXML%2F</url>
    <content type="text"><![CDATA[HTML, HTML5, XHTML和XML前端开发中HTML是一个基础概念，HTML5现在也基本成熟，但是也往往会听到XHTML、XML这些相关的概念。虽然现在HTML5近乎主流，弄懂这些相关概念也是很有用处的。 HTMLHyper Text Markup Language，超文本标记语言。搞前端开发的都知道，简单来说就是一个个标签，每个标签都有特定的意义。比如p标签表示段落，h1标签表示标题。HTML经历了多个版本，在HTML5出来之前，一般是HTML4. XHTMLExtensible Hyper Text Markup Language，可扩展超文本标签语言。由HTML升级而来，基本作用与HTML相似，但是语法要求上更加严格。举例来说，有以下几点区别： HTML不区分大小写，如&lt;P&gt;和&lt;p&gt;都可以表示p标签，而XHTML区分大小写，要求所有标签和属性都使用小写字母 在HTML中，即使只写了&lt;p&gt;忘记了写&lt;/p&gt;也是可以的，而XHTML要求所有的元素都有开始标签和结束标签 所有属性值都必须加上双引号 简单来说，HTML更加自由，而XHTML严格很多。 XMLExtensible Markup Language，可扩展标记语言。在HTML和XHTML中，只能使用预定好的标签，而在XML中可以自定义标签，并且是一种跨平台的语言。通常将XML和JSON联系起来，他们可以跨平台传输。 HTML5HTML的新一代标准，在HTML4的基础上引入了更多的标签，比如可以通过&lt;video&gt;标签在网页中插入一个视频，而不再需要FLASH。HTML5目前已经得到非常好的支持。 DOCTYPE标签综上所述，就HTML来说，已经至少有HTML4， XHTML和HTML5这三种标准，当然还有更细的划分。那么浏览器接收到一个HTML文件时，如何确定该使用哪一种标准来处理呢？这就需要用到&lt;!DOCTYPE&gt;标签。 &lt;!DOCTYPE&gt;位于HTML文档的头部，在&lt;html&gt;标签之前，这也说明它并不属于HTML标签。&lt;!DOCTYPE&gt;标签的不同值，决定了当前html文档采用的标准。比如下面的几个例子： 12345678&lt;!--HTML 4.01严格型--&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "https//www.w3.org/TR/html4/strict.dtc"&gt;&lt;!--XHTML1.0严格型--&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml-strict.dtd"&gt;&lt;!--html5--&gt;&lt;!DOCTYPE html&gt; //html5 需要说明的是，HTML4和XHTML的&lt;!DOCTYPE&gt;都引用了DTD，而HTML5不需要。这是因为HTML4.01基于 SGML，DTD规定了标记语言的规则，而 HTML 5 不基于 SGML。 浏览器的标准模式与怪异模式上面说的都是HTML标准，很多HTML并不一定遵循标准。这是因为在HTML和CSS标准化之前，各个浏览器对于HTML和CSS的解析有着不同的实现，也就是说每个厂商都有自己的一套标准，相信学前端的同学都听说过“浏览器大战”。所以存在两种类型的HTML：符合标准的HTML和老旧的HTML。作为浏览器，是需要同时支持者两类HTML的。所以，现代的浏览器都有标注模式和怪异模式。 如果使用了正确的&lt;!DOCTYPE&gt;，比如上面例子中的三个&lt;!DOCTYPE&gt;，浏览器就会启动标准模式。在标准模式下，浏览器就会按照指定的文档类型标准处理HTML文档，正确的进行解析和渲染。 老旧的HTML通常是没有&lt;!DOCTYPE&gt;声明的。所以，对于没有文档类型声明或者文档类型声明不正确的文档，浏览器就会认为它是一个旧的HTML文档，就会使用怪异模式解析和渲染该文档。在怪异模式下，浏览器则按照旧的非标准的实现方式对文档进行解析和渲染。 这样，浏览器就实现了对HTML的全面支持。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URL详解]]></title>
    <url>%2F2015%2F11%2F05%2FURL%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[URI，URL和URN通常大家对URL会比较熟悉，但是往往也会听到另外两个与之相关的概念：URI和URN。三者的区别如下： URI(Uniform Resource Identifier)：统一资源标识符，服务器上的每个资源都有一个唯一的名字，客户端可以通过名字来指出感兴趣的资源。URI可以唯一的指出并且定位这个资源 URL(uniform resource locator)：统一资源定位符，描述服务器上某个特定资源的位置信息 URN(Uniform Resource Names)：统一资源名称，针对某个特定资源的唯一名称，这个名称是独立的，与资源的存放位置无关。URN目前并没有被广泛采用，其中一个原因是缺少一个支持的结构来解决资源位置问题。 通俗地说，URL和URN是URI的子集，URI属于URL更高层次的抽象，一种字符串文本标准。如今，基本上每个URI都是一个URL。 URL的格式URL的一般格式，包括九个部分： 1&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt; Scheme部分：标识访问的协议，如常见的http和https。大小写不敏感，所以HTTP和http是相同的 user和password：默认的user是anonymous，默认的密码根据浏览器决定。user和password用来处理获取某些资源时，需要先使用用户名和密码登录的情况。 host：主机名，如www.baidu.com port：端口名 path：文件的存放路径 params：params部分是键值对，中间用分号分隔，params在某些协议下用来指定输入的参数 query： 位于?之后的查询参数，如?username=liugui&amp;age=24，参数之间用&amp;分隔 frag： #号分隔，表示指定资源某一个片段的名字，如HTML文档的一部分。在浏览器中输入这个URL，获取的是整个资源，但是浏览器显示时定位到frag指定的这个部分。其实frag参数严格意义上来说并没有发送到服务器处理，服务器处理的是整个资源，而浏览器处理决定显示frag指定的部分，就是HTML中的锚 常见的URL基本不会包含所有的九个部分，一般都是包含Scheme,host和path三个部分。 绝对URL和相对URL绝对URL还有完整的信息，而相对URL只有部分信息，必须相对于一个基址URL才能获取完整的信息。 相对URL的好处： 写起来相对于绝对URL要简洁，只包含部分信息 采用相对URL时，如果整个工程的目录改变，里面的链接仍然可以正常工作。 基址URL的确定： 明确指定了基址URL，比如HTML文档中的&lt;base&gt;标签指定基址URL 在某些资源中出现了超链接，但是未指定基址URL，那么这个超链接所在资源的URL就是基址URL。比如http://example.com/home.html中的超链接的基址是http://example.com/home.html; 注意包含后面的home.html 无基址URL，此时通常是绝对URL。 浏览器的URL自动补全在浏览器中输入URL时，为了方便浏览器提供自动补全功能，主要有以下两个方面： 对URL的完整性补全，如用户输入baidu.com，那么会自动补全http://和wwww 根据访问历史对URL的补全，在地址栏中输入URL的一部分时，会匹配最近访问历史URL。 URL的编码和解码不同的协议在编码时所用的机制可能不同，所以为了保证URL（指的是组成URL本身的字符串）能在不同的协议中传输，URL所用到的字符必须是一些通用的，安全的字符，这样就不会导致在不同系统中传递时URL的信息丢失。但是，这样就缩小了URL字符的范围。于是，为了扩展URL的字符范围以及URL中包含二进制数据，就有了URL的编码和解码机制，即将这些安全字符表以外的字符编码成安全字符来表示。 编码：%号后面接两位十六进制数字来表示一个字符]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码整洁之道读书笔记]]></title>
    <url>%2F2015%2F10%2F30%2F%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[《代码整洁之道》主要介绍如何写出整洁、高效、易读、易维护的代码，并不局限于某种特定的语言。书中以Java为例。书中开篇有一句话我觉得很重要：later equals never。在写代码的时候，往往想着先把功能做出来就行，以后再来优化代码，但往往这个later就变成了never。所以，在写代码的时候就应该要追求代码质量。 标识符命名：有意义，相似性低，避免前缀 好的命名应该不需要注释，命名本身应该指向明确，坐到名副其实 宁长也要精确，但是长的命名不要太相似，并且要做有意义的区分如productInfo和productData 易于搜索，易于判断，比如MAX_CLASSES_PER_STUDENT要比数字7易于搜索，意义更明确 类名和对象名应该是名词或者名词短语，不应该是动词 方法名应当是动词和动词短语 给每个抽象概念选择一个词，并且一以贯之，并且要保持一词一意，如fetch,save 变量名的长度应该跟作用域的大小成正比 解决方案领域和所涉问题领域：所涉问题领域 避免加前缀：自动补全列表很长 函数：短，参数少，每个函数只做一件事 函数的长度：每个函数的长度不要超过20行，每个函数的功能必须明确，都只做一件事，要根据抽象的层次划分。要确保函 数只做一件事，函数中的语句都要在同一抽象层级上 if等条件语句：包含的代码块应该只有一行，这一行是一个函数调用，调用的函数名应该有明显的指向性，指明这个函数完成的操作或者实现的功能 向下规则：每个函数后面都跟着位于下一个抽象层级上的函数 函数的参数：零参数函数最佳，参数越少越好，最多不要超过三个 函数命名时必须指定函数的明确功能或者使用条件，否则可能引起误用 函数的两大功能：要么去做一件事，或者回答一件事，但是二者不可兼得，在编写函数时，要将指令和询问分开 用try-catch代替返回错误码：用try-catch语句进行错误处理，而不是通过返回错误码，因为返回错误码时会将询问和指令混在一起。同时，try-catch语句要分离成单独的函数，才更有明确意义，同时也可以将正常流程与错误处理的两个过程分离 避免重复：重复的成分越多，代码就越差 具体实现时，可以先将功能实现，然后按照规则去修改函数 注释：真正的好代码不需要太多注释，但不能不写注释 真正好的代码不需要注释，注释只是用来弥补无法用代码表达意图的失败 警示注释：可能引起风险的函数，或者使用条件有限制的函数 TODO注释：以TODO开头，表示将来应该怎么样 HACK注释：如前端浏览器兼容性问题 不要保留注释的代码，注释掉的代码在源代码控制系统中可以找到，同样，作者的署名信息也可以在代码控制系统中找到 格式：横向80~120，缩进体现层级，纵向相关的代码靠近 空白行隔开不同概念的代码，而相关的代码可以靠近一些 横向的字符不要找过80，最高不要超过120 函数名和括号之间不要加空格，参数列表之间要加空格 乘除等优先级高的符号不要加空格，加减等优先级低的加空格 缩进：按照层级缩进 对象：隐藏数据，暴露方法 Demeter定律：模块不应该了解它所操作对象的内部情形 错误处理：错误处理应不影响代码逻辑，避免返回或者传递null值 使用异常try-catch，可避免搞乱代码逻辑 避免传递或者返回null值]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime中使用的快捷操作]]></title>
    <url>%2F2015%2F10%2F25%2FSublime%E4%B8%AD%E5%AE%9E%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Sublime Text是一款非常流行的代码编辑器，是前端工程师必备的工具之一。针对于Sublime Text3，我分别阅读了官方文档和非官方文档，总结了一些实用的快捷操作。由于现在使用的是Windows系统，所以都是针对windows系统下的Sublimte Text 3版本而言的。 编辑选中如果需要回退选中操作，可以用ctrl + u, u即undo的缩写。sublime中有两个撤销快捷键，ctrl + u 和ctrl + z，区别在于，ctrl + z只会记录对代码的改动，而ctrl + u还会记录光标的选择。 针对多列的选中鼠标操作：按住shift + 鼠标右键选定，如果需要多区域选定，则选定第二个区域时，按住ctrl + shift + 鼠标右键键盘操作：ctrl + alt + up 或者ctrl + alt + down 针对单词的选中鼠标操作： 双击选中当前这一个单词 键盘操作： ctrl + D选中当前单词，再次按下ctrl + D选择下一个单词， ctrl + K表示跳过这个单词， alt + f3选中所有，注：选中与高亮不同 针对多行的选中鼠标操作： 直接选中多行，如果分隔的，按住ctrl + 鼠标左键拖动 键盘操作：ctrl + shift + left向左和ctrl + shift + right向右选中一行中的某个单词，一行选满后回跳到下一行 其他的键盘编辑操作 ctrl + up和ctrl + down上下滚动 ctrl + shift + up和ctrl + shift + down对选中的内容所在行上下移动 选中一行： Ctrl + L 交换两个字母的顺序： Ctrl + T 搜索和替换单文件中搜索： ctrl + F 多文件中搜索: ctrl + shift + F（windows可能会与输入法冲突） 替换：ctrl + H 文件导航和文件管理搜索文件ctrl + p：在左侧栏的文件目录中搜索某个文件 高级用法： 同名的文件可能会有多个，如搜索image.js可能会显示多个文件，需要移动光标去选择自己需要的文件。一种简便的方法是，如果你记得文件的路径，可以在搜索时在文件名之前加上文件的路径，如ct/image.js便会很好的过滤搜索结果。文件路径一般不需要太长，一是太长了输入很慢，反而降低了效率，二是长了也根本记不住，一般往上写一级就可以了。 搜索文件同时定位文件中具体的位置：输入文件名后，看光标选中的是自己需要的文件后，就可以在输入框加入其它搜索条件对文件中的代码做进一步搜索。如：使用@后输入标识符可以搜索指定的函数或者类名，使用#加标识符可以搜索代码中包含搜索内容的单词并且高亮显示，使用:加数字可以定位到具体的行，回车后与搜索相符合的区域就会显示在屏幕上。 第二项中提到的功能，不仅仅是在搜索文件时，搜索文件打开之后也可以使用。如使用ctrl + R对应输入@的功能，使用ctrl + ;对应输入#的功能，使用ctrl + G对应输入:的功能。这种搜索方式与ctrl + F的不同之处在于搜索更加有针对性，而ctrl + F是搜索文件中的所有内容。 多视图要在一个窗口中打开多个tab，可以使用alt + shift + 1~9，注意小键盘区的数字按键不起作用，必须是位于键盘第二行的数字键才起作用 项目文件和工作空间项目文件对于每一个项目，可以建立一个.sublime-project为后缀的json文件，文件中可以保存针对这个项目的特定配置，如设定缩进规格,布局等，这个主要为了方便不同系统下的统一。 工作空间比如在同一个网站项目中，我需要负责两个页面的开发，页面一需要打开对应的9个文件，页面二需要打开对应的另外10个文件。如果每次都要手动打开，是非常麻烦的，所以可以用到workspace。在开发页面一时打开9个文件的状态就可以用一个workspace保存，下次需要开发页面一时直接载入这个workspace，就会自动打开这些页面，无序手动一个个打开。 创建：Project → New Workspace for Project 保存：Project → Save Workspace As…. 切换：ctrl + alt + p或者Project-&gt;Quick Switch Project 快捷键设定Sublime本身提供了很多快捷键，当然用户也可以自己定义快捷键。快捷键定义的文件也是一个JSON文件，以.sublime-keymap结尾，用户可以在用户文件夹下新建Default.sublime-keymap文件覆盖默认的快捷键设置。 扩展Sublime Text宏命令宏命令是一个命令集合，它会自动执行一系列的命令，让操作更简单。可以打开tools-&gt;Macros查看系统提供的基本宏命令。宏命令的定义在一个以.sublime-macro结尾的JOSN文件中。 如何记录宏命令如果你需要反复的进行多个相同的操作，那么使用宏命令可以大大简便。按下ctrl + q开始记录，此时可以看到软件左下角有提示，然后一步一步执行操作，完成后点击ctrl + q保存。那么，刚刚执行的所有操作都保存在宏命令缓存区中，如果之前有其他宏命令，会被覆盖，所以这只是一种不持久化的宏命令。如果要使用，直接按ctrl + shift + q就可以自动执行刚刚的宏命令。 如果要自定义可以保存的宏命令，需要在package中创建一个.sublime-macro结尾的JOSN文件，在里面写入多个命令，要执行时直接在tools-&gt;Macros里面点击即可。进一步，也可以定义快捷键执行宏文件，从而执行宏命令。 补全Sublime自带标识符补全的功能，补全主要是对于已经写过的内容，在后面写到时会自动弹出已经写过的内容选项列表，非常方便。自动补全有两种方法，按回车键或者Tab键。区别在于：按回车键表示当前的补全已经结束，而按Tab键之后还可以继续按多次，继续显示补全列表中下面的项。]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>Sublime 前端工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS盒模型里面的几个宽度问题]]></title>
    <url>%2F2015%2F10%2F20%2FCSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E9%87%8C%E9%9D%A2%E7%9A%84%E5%87%A0%E4%B8%AA%E5%AE%BD%E9%AB%98%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[盒模型是前端的一个基本概念，理解盒模型对于前端布局来说至关重要。 什么是盒模型简单来说，HTML中的任何一个DOM都可以看成是一个方块，这个方块就是所以的盒模型。如对于一个p标签： 1&lt;p&gt;Hello World!&lt;/p&gt; 将这个标签插入到HTML中，会显示一行文字Hello world!。 现在来看显示的只有文字，很难与一个盒模型联系起来。我们加上border属性看看： 1&lt;p style="border:1px solid black"&gt;Hello World!&lt;/p&gt; 加上边框后，看起来更加像一个“方盒子”了。其实，任何一个DOM都是这样一个方盒子，“hello world!”只是盒子里面装的东西，盒子本身还有边框、边距等属性，只是在默认情况下边框不显示而已。简单点理解，p标签本身相当于一个盒子，p标签里面的内容就是放在盒子里的东西，这个盒子将被放到网页的对应位置上，盒子的样式、位置等可以通过CSS设置。 盒模型包含的内容从里向外，盒模型主要包括四层： 盒模型里面的内容（content）：也就是实实在在要展现的内容，比如p标签里面的文字 盒模型的内边距（padding）：是内容与边框内部之间的距离 盒模型的边框（border）：盒子的边框，比如上面的例子中”hello world!”外面的黑色边框 盒模型的外边距（margin）：盒模型的边框外部与其他盒模型边框外部之间的距离 如果大家使用Chrome做过开发，在Chrome的控制台上，选中一个DOM时，就可以看到该DOM对应的盒模型信息，如下图所示： 图中最中间的蓝色区域，就是盒子里面放的内容，从里往外，分别对应padding, border,和margin。 盒模型中的几个宽高问题设置宽高CSS的width和height属性默认情况下设置的是内容区域（content）的宽高，不包括padding和border，也就是上图最中间蓝色区域的宽高。有时候希望定义的宽高不仅仅是针对内容区域，CSS3的box-sizing属性可以解决这个问题： 该属性值为content-box时，表示定义的是内容的宽度和高度，不包括padding、margin和border，该值是默认值。 该属性值为paading-box时，表示定义的是内容的宽度和高度加上padding的值，但是不包括margin和border。如果在这种情况下设置padding，那么会挤压内容的宽高。 该属性值为border-box时，表示定义的是内容的宽度和高度加上padding的值和border的值，但是不包括margin的值。如果在这种情况下设置padding和border，都会挤压内容的宽度，而设置margin则不会有影响。 操作宽高的属性和方法对于每个DOM，通常有以下几个关于宽高的属性，它们的意义分别是（以width为例，height同理）： offsetWidth属性：指的是盒模型的边框 + 内边距 + 内容的宽度 clientWidth属性：指的是盒模型的内边距 + 内容的宽度 scrollWidth属性：如果内容超出边框，需要有滚动条，那么scrollWidth获取的是整个文档的内容（而clientWidth获取的只是可见部分的宽度，相当于是这个盒模型中viewport的宽度） 另外，在jQuery中有三个与获取宽高相关的函数： outerWidth(): 获取或者设置offsetWidth； innerWidth(): 获取或者设置clientWidth； width(): 获取或者设置内容的宽度，如果此时box-sizing为border-box，那么会自动增加border和padding的值到width的实际值上。比如，当前的border-left的宽度为20px，如果通过width函数设置宽度为80px，那么实际上在控制台上可以看到DOM中的style=”width:100px”。正好是设置的80px加上border的20px。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
</search>
